// Copyright (c) 2016 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

// @generated Code generated by thrift-gen. Do not modify.

// Package replicator is generated code used to make or handle TChannel calls using Thrift.
package replicator

import (
	"fmt"

	athrift "github.com/apache/thrift/lib/go/thrift"
	"github.com/uber/tchannel-go/thrift"

	"github.com/uber/cherami-thrift/.generated/go/shared"
)

var _ = shared.GoUnusedProtection__

// Interfaces for the service and client for the services defined in the IDL.

// TChanReplicator is the interface that defines the server handler and client interface.
type TChanReplicator interface {
	CreateConsumerGroupUUID(ctx thrift.Context, createRequest *shared.CreateConsumerGroupUUIDRequest) (*shared.ConsumerGroupDescription, error)
	CreateDestinationUUID(ctx thrift.Context, createRequest *shared.CreateDestinationUUIDRequest) (*shared.DestinationDescription, error)
	CreateExtent(ctx thrift.Context, createRequest *shared.CreateExtentRequest) (*shared.CreateExtentResult_, error)
	CreateRemoteConsumerGroupUUID(ctx thrift.Context, createRequest *shared.CreateConsumerGroupUUIDRequest) error
	CreateRemoteDestinationUUID(ctx thrift.Context, createRequest *shared.CreateDestinationUUIDRequest) error
	CreateRemoteExtent(ctx thrift.Context, createRequest *shared.CreateExtentRequest) error
	DeleteConsumerGroup(ctx thrift.Context, deleteRequest *shared.DeleteConsumerGroupRequest) error
	DeleteDestination(ctx thrift.Context, deleteRequest *shared.DeleteDestinationRequest) error
	DeleteRemoteConsumerGroup(ctx thrift.Context, deleteRequest *shared.DeleteConsumerGroupRequest) error
	DeleteRemoteDestination(ctx thrift.Context, deleteRequest *shared.DeleteDestinationRequest) error
	ListConsumerGroups(ctx thrift.Context, listRequest *shared.ListConsumerGroupRequest) (*shared.ListConsumerGroupResult_, error)
	ListDestinations(ctx thrift.Context, listRequest *shared.ListDestinationsRequest) (*shared.ListDestinationsResult_, error)
	ListDestinationsByUUID(ctx thrift.Context, listRequest *shared.ListDestinationsByUUIDRequest) (*shared.ListDestinationsResult_, error)
	ListExtentsStats(ctx thrift.Context, request *shared.ListExtentsStatsRequest) (*shared.ListExtentsStatsResult_, error)
	ReadDestination(ctx thrift.Context, getRequest *shared.ReadDestinationRequest) (*shared.DestinationDescription, error)
	UpdateConsumerGroup(ctx thrift.Context, updateRequest *shared.UpdateConsumerGroupRequest) (*shared.ConsumerGroupDescription, error)
	UpdateDestination(ctx thrift.Context, updateRequest *shared.UpdateDestinationRequest) (*shared.DestinationDescription, error)
	UpdateRemoteConsumerGroup(ctx thrift.Context, updateRequest *shared.UpdateConsumerGroupRequest) error
	UpdateRemoteDestination(ctx thrift.Context, updateRequest *shared.UpdateDestinationRequest) error
}

// Implementation of a client and service handler.

type tchanReplicatorClient struct {
	thriftService string
	client        thrift.TChanClient
}

func NewTChanReplicatorInheritedClient(thriftService string, client thrift.TChanClient) *tchanReplicatorClient {
	return &tchanReplicatorClient{
		thriftService,
		client,
	}
}

// NewTChanReplicatorClient creates a client that can be used to make remote calls.
func NewTChanReplicatorClient(client thrift.TChanClient) TChanReplicator {
	return NewTChanReplicatorInheritedClient("Replicator", client)
}

func (c *tchanReplicatorClient) CreateConsumerGroupUUID(ctx thrift.Context, createRequest *shared.CreateConsumerGroupUUIDRequest) (*shared.ConsumerGroupDescription, error) {
	var resp ReplicatorCreateConsumerGroupUUIDResult
	args := ReplicatorCreateConsumerGroupUUIDArgs{
		CreateRequest: createRequest,
	}
	success, err := c.client.Call(ctx, c.thriftService, "createConsumerGroupUUID", &args, &resp)
	if err == nil && !success {
		switch {
		case resp.EntityExistsError != nil:
			err = resp.EntityExistsError
		case resp.RequestError != nil:
			err = resp.RequestError
		case resp.InternalServiceError != nil:
			err = resp.InternalServiceError
		default:
			err = fmt.Errorf("received no result or unknown exception for createConsumerGroupUUID")
		}
	}

	return resp.GetSuccess(), err
}

func (c *tchanReplicatorClient) CreateDestinationUUID(ctx thrift.Context, createRequest *shared.CreateDestinationUUIDRequest) (*shared.DestinationDescription, error) {
	var resp ReplicatorCreateDestinationUUIDResult
	args := ReplicatorCreateDestinationUUIDArgs{
		CreateRequest: createRequest,
	}
	success, err := c.client.Call(ctx, c.thriftService, "createDestinationUUID", &args, &resp)
	if err == nil && !success {
		switch {
		case resp.EntityExistsError != nil:
			err = resp.EntityExistsError
		case resp.RequestError != nil:
			err = resp.RequestError
		case resp.InternalServiceError != nil:
			err = resp.InternalServiceError
		default:
			err = fmt.Errorf("received no result or unknown exception for createDestinationUUID")
		}
	}

	return resp.GetSuccess(), err
}

func (c *tchanReplicatorClient) CreateExtent(ctx thrift.Context, createRequest *shared.CreateExtentRequest) (*shared.CreateExtentResult_, error) {
	var resp ReplicatorCreateExtentResult
	args := ReplicatorCreateExtentArgs{
		CreateRequest: createRequest,
	}
	success, err := c.client.Call(ctx, c.thriftService, "createExtent", &args, &resp)
	if err == nil && !success {
		switch {
		case resp.EntityExistsError != nil:
			err = resp.EntityExistsError
		case resp.RequestError != nil:
			err = resp.RequestError
		case resp.InternalServiceError != nil:
			err = resp.InternalServiceError
		default:
			err = fmt.Errorf("received no result or unknown exception for createExtent")
		}
	}

	return resp.GetSuccess(), err
}

func (c *tchanReplicatorClient) CreateRemoteConsumerGroupUUID(ctx thrift.Context, createRequest *shared.CreateConsumerGroupUUIDRequest) error {
	var resp ReplicatorCreateRemoteConsumerGroupUUIDResult
	args := ReplicatorCreateRemoteConsumerGroupUUIDArgs{
		CreateRequest: createRequest,
	}
	success, err := c.client.Call(ctx, c.thriftService, "createRemoteConsumerGroupUUID", &args, &resp)
	if err == nil && !success {
		switch {
		case resp.EntityExistsError != nil:
			err = resp.EntityExistsError
		case resp.RequestError != nil:
			err = resp.RequestError
		case resp.InternalServiceError != nil:
			err = resp.InternalServiceError
		default:
			err = fmt.Errorf("received no result or unknown exception for createRemoteConsumerGroupUUID")
		}
	}

	return err
}

func (c *tchanReplicatorClient) CreateRemoteDestinationUUID(ctx thrift.Context, createRequest *shared.CreateDestinationUUIDRequest) error {
	var resp ReplicatorCreateRemoteDestinationUUIDResult
	args := ReplicatorCreateRemoteDestinationUUIDArgs{
		CreateRequest: createRequest,
	}
	success, err := c.client.Call(ctx, c.thriftService, "createRemoteDestinationUUID", &args, &resp)
	if err == nil && !success {
		switch {
		case resp.EntityExistsError != nil:
			err = resp.EntityExistsError
		case resp.RequestError != nil:
			err = resp.RequestError
		case resp.InternalServiceError != nil:
			err = resp.InternalServiceError
		default:
			err = fmt.Errorf("received no result or unknown exception for createRemoteDestinationUUID")
		}
	}

	return err
}

func (c *tchanReplicatorClient) CreateRemoteExtent(ctx thrift.Context, createRequest *shared.CreateExtentRequest) error {
	var resp ReplicatorCreateRemoteExtentResult
	args := ReplicatorCreateRemoteExtentArgs{
		CreateRequest: createRequest,
	}
	success, err := c.client.Call(ctx, c.thriftService, "createRemoteExtent", &args, &resp)
	if err == nil && !success {
		switch {
		case resp.EntityExistsError != nil:
			err = resp.EntityExistsError
		case resp.RequestError != nil:
			err = resp.RequestError
		case resp.InternalServiceError != nil:
			err = resp.InternalServiceError
		default:
			err = fmt.Errorf("received no result or unknown exception for createRemoteExtent")
		}
	}

	return err
}

func (c *tchanReplicatorClient) DeleteConsumerGroup(ctx thrift.Context, deleteRequest *shared.DeleteConsumerGroupRequest) error {
	var resp ReplicatorDeleteConsumerGroupResult
	args := ReplicatorDeleteConsumerGroupArgs{
		DeleteRequest: deleteRequest,
	}
	success, err := c.client.Call(ctx, c.thriftService, "deleteConsumerGroup", &args, &resp)
	if err == nil && !success {
		switch {
		case resp.EntityError != nil:
			err = resp.EntityError
		case resp.RequestError != nil:
			err = resp.RequestError
		case resp.InternalServiceError != nil:
			err = resp.InternalServiceError
		default:
			err = fmt.Errorf("received no result or unknown exception for deleteConsumerGroup")
		}
	}

	return err
}

func (c *tchanReplicatorClient) DeleteDestination(ctx thrift.Context, deleteRequest *shared.DeleteDestinationRequest) error {
	var resp ReplicatorDeleteDestinationResult
	args := ReplicatorDeleteDestinationArgs{
		DeleteRequest: deleteRequest,
	}
	success, err := c.client.Call(ctx, c.thriftService, "deleteDestination", &args, &resp)
	if err == nil && !success {
		switch {
		case resp.EntityError != nil:
			err = resp.EntityError
		case resp.RequestError != nil:
			err = resp.RequestError
		case resp.InternalServiceError != nil:
			err = resp.InternalServiceError
		default:
			err = fmt.Errorf("received no result or unknown exception for deleteDestination")
		}
	}

	return err
}

func (c *tchanReplicatorClient) DeleteRemoteConsumerGroup(ctx thrift.Context, deleteRequest *shared.DeleteConsumerGroupRequest) error {
	var resp ReplicatorDeleteRemoteConsumerGroupResult
	args := ReplicatorDeleteRemoteConsumerGroupArgs{
		DeleteRequest: deleteRequest,
	}
	success, err := c.client.Call(ctx, c.thriftService, "deleteRemoteConsumerGroup", &args, &resp)
	if err == nil && !success {
		switch {
		case resp.EntityError != nil:
			err = resp.EntityError
		case resp.RequestError != nil:
			err = resp.RequestError
		case resp.InternalServiceError != nil:
			err = resp.InternalServiceError
		default:
			err = fmt.Errorf("received no result or unknown exception for deleteRemoteConsumerGroup")
		}
	}

	return err
}

func (c *tchanReplicatorClient) DeleteRemoteDestination(ctx thrift.Context, deleteRequest *shared.DeleteDestinationRequest) error {
	var resp ReplicatorDeleteRemoteDestinationResult
	args := ReplicatorDeleteRemoteDestinationArgs{
		DeleteRequest: deleteRequest,
	}
	success, err := c.client.Call(ctx, c.thriftService, "deleteRemoteDestination", &args, &resp)
	if err == nil && !success {
		switch {
		case resp.EntityError != nil:
			err = resp.EntityError
		case resp.RequestError != nil:
			err = resp.RequestError
		case resp.InternalServiceError != nil:
			err = resp.InternalServiceError
		default:
			err = fmt.Errorf("received no result or unknown exception for deleteRemoteDestination")
		}
	}

	return err
}

func (c *tchanReplicatorClient) ListConsumerGroups(ctx thrift.Context, listRequest *shared.ListConsumerGroupRequest) (*shared.ListConsumerGroupResult_, error) {
	var resp ReplicatorListConsumerGroupsResult
	args := ReplicatorListConsumerGroupsArgs{
		ListRequest: listRequest,
	}
	success, err := c.client.Call(ctx, c.thriftService, "listConsumerGroups", &args, &resp)
	if err == nil && !success {
		switch {
		case resp.RequestError != nil:
			err = resp.RequestError
		case resp.InternalError != nil:
			err = resp.InternalError
		default:
			err = fmt.Errorf("received no result or unknown exception for listConsumerGroups")
		}
	}

	return resp.GetSuccess(), err
}

func (c *tchanReplicatorClient) ListDestinations(ctx thrift.Context, listRequest *shared.ListDestinationsRequest) (*shared.ListDestinationsResult_, error) {
	var resp ReplicatorListDestinationsResult
	args := ReplicatorListDestinationsArgs{
		ListRequest: listRequest,
	}
	success, err := c.client.Call(ctx, c.thriftService, "listDestinations", &args, &resp)
	if err == nil && !success {
		switch {
		case resp.RequestError != nil:
			err = resp.RequestError
		case resp.InternalServiceError != nil:
			err = resp.InternalServiceError
		default:
			err = fmt.Errorf("received no result or unknown exception for listDestinations")
		}
	}

	return resp.GetSuccess(), err
}

func (c *tchanReplicatorClient) ListDestinationsByUUID(ctx thrift.Context, listRequest *shared.ListDestinationsByUUIDRequest) (*shared.ListDestinationsResult_, error) {
	var resp ReplicatorListDestinationsByUUIDResult
	args := ReplicatorListDestinationsByUUIDArgs{
		ListRequest: listRequest,
	}
	success, err := c.client.Call(ctx, c.thriftService, "listDestinationsByUUID", &args, &resp)
	if err == nil && !success {
		switch {
		case resp.RequestError != nil:
			err = resp.RequestError
		case resp.InternalServiceError != nil:
			err = resp.InternalServiceError
		default:
			err = fmt.Errorf("received no result or unknown exception for listDestinationsByUUID")
		}
	}

	return resp.GetSuccess(), err
}

func (c *tchanReplicatorClient) ListExtentsStats(ctx thrift.Context, request *shared.ListExtentsStatsRequest) (*shared.ListExtentsStatsResult_, error) {
	var resp ReplicatorListExtentsStatsResult
	args := ReplicatorListExtentsStatsArgs{
		Request: request,
	}
	success, err := c.client.Call(ctx, c.thriftService, "listExtentsStats", &args, &resp)
	if err == nil && !success {
		switch {
		case resp.RequestError != nil:
			err = resp.RequestError
		case resp.InternalServiceError != nil:
			err = resp.InternalServiceError
		default:
			err = fmt.Errorf("received no result or unknown exception for listExtentsStats")
		}
	}

	return resp.GetSuccess(), err
}

func (c *tchanReplicatorClient) ReadDestination(ctx thrift.Context, getRequest *shared.ReadDestinationRequest) (*shared.DestinationDescription, error) {
	var resp ReplicatorReadDestinationResult
	args := ReplicatorReadDestinationArgs{
		GetRequest: getRequest,
	}
	success, err := c.client.Call(ctx, c.thriftService, "readDestination", &args, &resp)
	if err == nil && !success {
		switch {
		case resp.EntityError != nil:
			err = resp.EntityError
		case resp.RequestError != nil:
			err = resp.RequestError
		case resp.InternalServiceError != nil:
			err = resp.InternalServiceError
		default:
			err = fmt.Errorf("received no result or unknown exception for readDestination")
		}
	}

	return resp.GetSuccess(), err
}

func (c *tchanReplicatorClient) UpdateConsumerGroup(ctx thrift.Context, updateRequest *shared.UpdateConsumerGroupRequest) (*shared.ConsumerGroupDescription, error) {
	var resp ReplicatorUpdateConsumerGroupResult
	args := ReplicatorUpdateConsumerGroupArgs{
		UpdateRequest: updateRequest,
	}
	success, err := c.client.Call(ctx, c.thriftService, "updateConsumerGroup", &args, &resp)
	if err == nil && !success {
		switch {
		case resp.EntityError != nil:
			err = resp.EntityError
		case resp.RequestError != nil:
			err = resp.RequestError
		case resp.InternalServiceError != nil:
			err = resp.InternalServiceError
		default:
			err = fmt.Errorf("received no result or unknown exception for updateConsumerGroup")
		}
	}

	return resp.GetSuccess(), err
}

func (c *tchanReplicatorClient) UpdateDestination(ctx thrift.Context, updateRequest *shared.UpdateDestinationRequest) (*shared.DestinationDescription, error) {
	var resp ReplicatorUpdateDestinationResult
	args := ReplicatorUpdateDestinationArgs{
		UpdateRequest: updateRequest,
	}
	success, err := c.client.Call(ctx, c.thriftService, "updateDestination", &args, &resp)
	if err == nil && !success {
		switch {
		case resp.EntityError != nil:
			err = resp.EntityError
		case resp.RequestError != nil:
			err = resp.RequestError
		case resp.InternalServiceError != nil:
			err = resp.InternalServiceError
		default:
			err = fmt.Errorf("received no result or unknown exception for updateDestination")
		}
	}

	return resp.GetSuccess(), err
}

func (c *tchanReplicatorClient) UpdateRemoteConsumerGroup(ctx thrift.Context, updateRequest *shared.UpdateConsumerGroupRequest) error {
	var resp ReplicatorUpdateRemoteConsumerGroupResult
	args := ReplicatorUpdateRemoteConsumerGroupArgs{
		UpdateRequest: updateRequest,
	}
	success, err := c.client.Call(ctx, c.thriftService, "updateRemoteConsumerGroup", &args, &resp)
	if err == nil && !success {
		switch {
		case resp.EntityError != nil:
			err = resp.EntityError
		case resp.RequestError != nil:
			err = resp.RequestError
		case resp.InternalServiceError != nil:
			err = resp.InternalServiceError
		default:
			err = fmt.Errorf("received no result or unknown exception for updateRemoteConsumerGroup")
		}
	}

	return err
}

func (c *tchanReplicatorClient) UpdateRemoteDestination(ctx thrift.Context, updateRequest *shared.UpdateDestinationRequest) error {
	var resp ReplicatorUpdateRemoteDestinationResult
	args := ReplicatorUpdateRemoteDestinationArgs{
		UpdateRequest: updateRequest,
	}
	success, err := c.client.Call(ctx, c.thriftService, "updateRemoteDestination", &args, &resp)
	if err == nil && !success {
		switch {
		case resp.EntityError != nil:
			err = resp.EntityError
		case resp.RequestError != nil:
			err = resp.RequestError
		case resp.InternalServiceError != nil:
			err = resp.InternalServiceError
		default:
			err = fmt.Errorf("received no result or unknown exception for updateRemoteDestination")
		}
	}

	return err
}

type tchanReplicatorServer struct {
	handler TChanReplicator
}

// NewTChanReplicatorServer wraps a handler for TChanReplicator so it can be
// registered with a thrift.Server.
func NewTChanReplicatorServer(handler TChanReplicator) thrift.TChanServer {
	return &tchanReplicatorServer{
		handler,
	}
}

func (s *tchanReplicatorServer) Service() string {
	return "Replicator"
}

func (s *tchanReplicatorServer) Methods() []string {
	return []string{
		"createConsumerGroupUUID",
		"createDestinationUUID",
		"createExtent",
		"createRemoteConsumerGroupUUID",
		"createRemoteDestinationUUID",
		"createRemoteExtent",
		"deleteConsumerGroup",
		"deleteDestination",
		"deleteRemoteConsumerGroup",
		"deleteRemoteDestination",
		"listConsumerGroups",
		"listDestinations",
		"listDestinationsByUUID",
		"listExtentsStats",
		"readDestination",
		"updateConsumerGroup",
		"updateDestination",
		"updateRemoteConsumerGroup",
		"updateRemoteDestination",
	}
}

func (s *tchanReplicatorServer) Handle(ctx thrift.Context, methodName string, protocol athrift.TProtocol) (bool, athrift.TStruct, error) {
	switch methodName {
	case "createConsumerGroupUUID":
		return s.handleCreateConsumerGroupUUID(ctx, protocol)
	case "createDestinationUUID":
		return s.handleCreateDestinationUUID(ctx, protocol)
	case "createExtent":
		return s.handleCreateExtent(ctx, protocol)
	case "createRemoteConsumerGroupUUID":
		return s.handleCreateRemoteConsumerGroupUUID(ctx, protocol)
	case "createRemoteDestinationUUID":
		return s.handleCreateRemoteDestinationUUID(ctx, protocol)
	case "createRemoteExtent":
		return s.handleCreateRemoteExtent(ctx, protocol)
	case "deleteConsumerGroup":
		return s.handleDeleteConsumerGroup(ctx, protocol)
	case "deleteDestination":
		return s.handleDeleteDestination(ctx, protocol)
	case "deleteRemoteConsumerGroup":
		return s.handleDeleteRemoteConsumerGroup(ctx, protocol)
	case "deleteRemoteDestination":
		return s.handleDeleteRemoteDestination(ctx, protocol)
	case "listConsumerGroups":
		return s.handleListConsumerGroups(ctx, protocol)
	case "listDestinations":
		return s.handleListDestinations(ctx, protocol)
	case "listDestinationsByUUID":
		return s.handleListDestinationsByUUID(ctx, protocol)
	case "listExtentsStats":
		return s.handleListExtentsStats(ctx, protocol)
	case "readDestination":
		return s.handleReadDestination(ctx, protocol)
	case "updateConsumerGroup":
		return s.handleUpdateConsumerGroup(ctx, protocol)
	case "updateDestination":
		return s.handleUpdateDestination(ctx, protocol)
	case "updateRemoteConsumerGroup":
		return s.handleUpdateRemoteConsumerGroup(ctx, protocol)
	case "updateRemoteDestination":
		return s.handleUpdateRemoteDestination(ctx, protocol)

	default:
		return false, nil, fmt.Errorf("method %v not found in service %v", methodName, s.Service())
	}
}

func (s *tchanReplicatorServer) handleCreateConsumerGroupUUID(ctx thrift.Context, protocol athrift.TProtocol) (bool, athrift.TStruct, error) {
	var req ReplicatorCreateConsumerGroupUUIDArgs
	var res ReplicatorCreateConsumerGroupUUIDResult

	if err := req.Read(protocol); err != nil {
		return false, nil, err
	}

	r, err :=
		s.handler.CreateConsumerGroupUUID(ctx, req.CreateRequest)

	if err != nil {
		switch v := err.(type) {
		case *shared.EntityAlreadyExistsError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for entityExistsError returned non-nil error type *shared.EntityAlreadyExistsError but nil value")
			}
			res.EntityExistsError = v
		case *shared.BadRequestError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for requestError returned non-nil error type *shared.BadRequestError but nil value")
			}
			res.RequestError = v
		case *shared.InternalServiceError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for internalServiceError returned non-nil error type *shared.InternalServiceError but nil value")
			}
			res.InternalServiceError = v
		default:
			return false, nil, err
		}
	} else {
		res.Success = r
	}

	return err == nil, &res, nil
}

func (s *tchanReplicatorServer) handleCreateDestinationUUID(ctx thrift.Context, protocol athrift.TProtocol) (bool, athrift.TStruct, error) {
	var req ReplicatorCreateDestinationUUIDArgs
	var res ReplicatorCreateDestinationUUIDResult

	if err := req.Read(protocol); err != nil {
		return false, nil, err
	}

	r, err :=
		s.handler.CreateDestinationUUID(ctx, req.CreateRequest)

	if err != nil {
		switch v := err.(type) {
		case *shared.EntityAlreadyExistsError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for entityExistsError returned non-nil error type *shared.EntityAlreadyExistsError but nil value")
			}
			res.EntityExistsError = v
		case *shared.BadRequestError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for requestError returned non-nil error type *shared.BadRequestError but nil value")
			}
			res.RequestError = v
		case *shared.InternalServiceError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for internalServiceError returned non-nil error type *shared.InternalServiceError but nil value")
			}
			res.InternalServiceError = v
		default:
			return false, nil, err
		}
	} else {
		res.Success = r
	}

	return err == nil, &res, nil
}

func (s *tchanReplicatorServer) handleCreateExtent(ctx thrift.Context, protocol athrift.TProtocol) (bool, athrift.TStruct, error) {
	var req ReplicatorCreateExtentArgs
	var res ReplicatorCreateExtentResult

	if err := req.Read(protocol); err != nil {
		return false, nil, err
	}

	r, err :=
		s.handler.CreateExtent(ctx, req.CreateRequest)

	if err != nil {
		switch v := err.(type) {
		case *shared.EntityAlreadyExistsError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for entityExistsError returned non-nil error type *shared.EntityAlreadyExistsError but nil value")
			}
			res.EntityExistsError = v
		case *shared.BadRequestError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for requestError returned non-nil error type *shared.BadRequestError but nil value")
			}
			res.RequestError = v
		case *shared.InternalServiceError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for internalServiceError returned non-nil error type *shared.InternalServiceError but nil value")
			}
			res.InternalServiceError = v
		default:
			return false, nil, err
		}
	} else {
		res.Success = r
	}

	return err == nil, &res, nil
}

func (s *tchanReplicatorServer) handleCreateRemoteConsumerGroupUUID(ctx thrift.Context, protocol athrift.TProtocol) (bool, athrift.TStruct, error) {
	var req ReplicatorCreateRemoteConsumerGroupUUIDArgs
	var res ReplicatorCreateRemoteConsumerGroupUUIDResult

	if err := req.Read(protocol); err != nil {
		return false, nil, err
	}

	err :=
		s.handler.CreateRemoteConsumerGroupUUID(ctx, req.CreateRequest)

	if err != nil {
		switch v := err.(type) {
		case *shared.EntityAlreadyExistsError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for entityExistsError returned non-nil error type *shared.EntityAlreadyExistsError but nil value")
			}
			res.EntityExistsError = v
		case *shared.BadRequestError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for requestError returned non-nil error type *shared.BadRequestError but nil value")
			}
			res.RequestError = v
		case *shared.InternalServiceError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for internalServiceError returned non-nil error type *shared.InternalServiceError but nil value")
			}
			res.InternalServiceError = v
		default:
			return false, nil, err
		}
	} else {
	}

	return err == nil, &res, nil
}

func (s *tchanReplicatorServer) handleCreateRemoteDestinationUUID(ctx thrift.Context, protocol athrift.TProtocol) (bool, athrift.TStruct, error) {
	var req ReplicatorCreateRemoteDestinationUUIDArgs
	var res ReplicatorCreateRemoteDestinationUUIDResult

	if err := req.Read(protocol); err != nil {
		return false, nil, err
	}

	err :=
		s.handler.CreateRemoteDestinationUUID(ctx, req.CreateRequest)

	if err != nil {
		switch v := err.(type) {
		case *shared.EntityAlreadyExistsError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for entityExistsError returned non-nil error type *shared.EntityAlreadyExistsError but nil value")
			}
			res.EntityExistsError = v
		case *shared.BadRequestError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for requestError returned non-nil error type *shared.BadRequestError but nil value")
			}
			res.RequestError = v
		case *shared.InternalServiceError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for internalServiceError returned non-nil error type *shared.InternalServiceError but nil value")
			}
			res.InternalServiceError = v
		default:
			return false, nil, err
		}
	} else {
	}

	return err == nil, &res, nil
}

func (s *tchanReplicatorServer) handleCreateRemoteExtent(ctx thrift.Context, protocol athrift.TProtocol) (bool, athrift.TStruct, error) {
	var req ReplicatorCreateRemoteExtentArgs
	var res ReplicatorCreateRemoteExtentResult

	if err := req.Read(protocol); err != nil {
		return false, nil, err
	}

	err :=
		s.handler.CreateRemoteExtent(ctx, req.CreateRequest)

	if err != nil {
		switch v := err.(type) {
		case *shared.EntityAlreadyExistsError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for entityExistsError returned non-nil error type *shared.EntityAlreadyExistsError but nil value")
			}
			res.EntityExistsError = v
		case *shared.BadRequestError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for requestError returned non-nil error type *shared.BadRequestError but nil value")
			}
			res.RequestError = v
		case *shared.InternalServiceError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for internalServiceError returned non-nil error type *shared.InternalServiceError but nil value")
			}
			res.InternalServiceError = v
		default:
			return false, nil, err
		}
	} else {
	}

	return err == nil, &res, nil
}

func (s *tchanReplicatorServer) handleDeleteConsumerGroup(ctx thrift.Context, protocol athrift.TProtocol) (bool, athrift.TStruct, error) {
	var req ReplicatorDeleteConsumerGroupArgs
	var res ReplicatorDeleteConsumerGroupResult

	if err := req.Read(protocol); err != nil {
		return false, nil, err
	}

	err :=
		s.handler.DeleteConsumerGroup(ctx, req.DeleteRequest)

	if err != nil {
		switch v := err.(type) {
		case *shared.EntityNotExistsError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for entityError returned non-nil error type *shared.EntityNotExistsError but nil value")
			}
			res.EntityError = v
		case *shared.BadRequestError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for requestError returned non-nil error type *shared.BadRequestError but nil value")
			}
			res.RequestError = v
		case *shared.InternalServiceError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for internalServiceError returned non-nil error type *shared.InternalServiceError but nil value")
			}
			res.InternalServiceError = v
		default:
			return false, nil, err
		}
	} else {
	}

	return err == nil, &res, nil
}

func (s *tchanReplicatorServer) handleDeleteDestination(ctx thrift.Context, protocol athrift.TProtocol) (bool, athrift.TStruct, error) {
	var req ReplicatorDeleteDestinationArgs
	var res ReplicatorDeleteDestinationResult

	if err := req.Read(protocol); err != nil {
		return false, nil, err
	}

	err :=
		s.handler.DeleteDestination(ctx, req.DeleteRequest)

	if err != nil {
		switch v := err.(type) {
		case *shared.EntityNotExistsError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for entityError returned non-nil error type *shared.EntityNotExistsError but nil value")
			}
			res.EntityError = v
		case *shared.BadRequestError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for requestError returned non-nil error type *shared.BadRequestError but nil value")
			}
			res.RequestError = v
		case *shared.InternalServiceError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for internalServiceError returned non-nil error type *shared.InternalServiceError but nil value")
			}
			res.InternalServiceError = v
		default:
			return false, nil, err
		}
	} else {
	}

	return err == nil, &res, nil
}

func (s *tchanReplicatorServer) handleDeleteRemoteConsumerGroup(ctx thrift.Context, protocol athrift.TProtocol) (bool, athrift.TStruct, error) {
	var req ReplicatorDeleteRemoteConsumerGroupArgs
	var res ReplicatorDeleteRemoteConsumerGroupResult

	if err := req.Read(protocol); err != nil {
		return false, nil, err
	}

	err :=
		s.handler.DeleteRemoteConsumerGroup(ctx, req.DeleteRequest)

	if err != nil {
		switch v := err.(type) {
		case *shared.EntityNotExistsError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for entityError returned non-nil error type *shared.EntityNotExistsError but nil value")
			}
			res.EntityError = v
		case *shared.BadRequestError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for requestError returned non-nil error type *shared.BadRequestError but nil value")
			}
			res.RequestError = v
		case *shared.InternalServiceError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for internalServiceError returned non-nil error type *shared.InternalServiceError but nil value")
			}
			res.InternalServiceError = v
		default:
			return false, nil, err
		}
	} else {
	}

	return err == nil, &res, nil
}

func (s *tchanReplicatorServer) handleDeleteRemoteDestination(ctx thrift.Context, protocol athrift.TProtocol) (bool, athrift.TStruct, error) {
	var req ReplicatorDeleteRemoteDestinationArgs
	var res ReplicatorDeleteRemoteDestinationResult

	if err := req.Read(protocol); err != nil {
		return false, nil, err
	}

	err :=
		s.handler.DeleteRemoteDestination(ctx, req.DeleteRequest)

	if err != nil {
		switch v := err.(type) {
		case *shared.EntityNotExistsError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for entityError returned non-nil error type *shared.EntityNotExistsError but nil value")
			}
			res.EntityError = v
		case *shared.BadRequestError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for requestError returned non-nil error type *shared.BadRequestError but nil value")
			}
			res.RequestError = v
		case *shared.InternalServiceError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for internalServiceError returned non-nil error type *shared.InternalServiceError but nil value")
			}
			res.InternalServiceError = v
		default:
			return false, nil, err
		}
	} else {
	}

	return err == nil, &res, nil
}

func (s *tchanReplicatorServer) handleListConsumerGroups(ctx thrift.Context, protocol athrift.TProtocol) (bool, athrift.TStruct, error) {
	var req ReplicatorListConsumerGroupsArgs
	var res ReplicatorListConsumerGroupsResult

	if err := req.Read(protocol); err != nil {
		return false, nil, err
	}

	r, err :=
		s.handler.ListConsumerGroups(ctx, req.ListRequest)

	if err != nil {
		switch v := err.(type) {
		case *shared.BadRequestError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for requestError returned non-nil error type *shared.BadRequestError but nil value")
			}
			res.RequestError = v
		case *shared.InternalServiceError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for internalError returned non-nil error type *shared.InternalServiceError but nil value")
			}
			res.InternalError = v
		default:
			return false, nil, err
		}
	} else {
		res.Success = r
	}

	return err == nil, &res, nil
}

func (s *tchanReplicatorServer) handleListDestinations(ctx thrift.Context, protocol athrift.TProtocol) (bool, athrift.TStruct, error) {
	var req ReplicatorListDestinationsArgs
	var res ReplicatorListDestinationsResult

	if err := req.Read(protocol); err != nil {
		return false, nil, err
	}

	r, err :=
		s.handler.ListDestinations(ctx, req.ListRequest)

	if err != nil {
		switch v := err.(type) {
		case *shared.BadRequestError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for requestError returned non-nil error type *shared.BadRequestError but nil value")
			}
			res.RequestError = v
		case *shared.InternalServiceError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for internalServiceError returned non-nil error type *shared.InternalServiceError but nil value")
			}
			res.InternalServiceError = v
		default:
			return false, nil, err
		}
	} else {
		res.Success = r
	}

	return err == nil, &res, nil
}

func (s *tchanReplicatorServer) handleListDestinationsByUUID(ctx thrift.Context, protocol athrift.TProtocol) (bool, athrift.TStruct, error) {
	var req ReplicatorListDestinationsByUUIDArgs
	var res ReplicatorListDestinationsByUUIDResult

	if err := req.Read(protocol); err != nil {
		return false, nil, err
	}

	r, err :=
		s.handler.ListDestinationsByUUID(ctx, req.ListRequest)

	if err != nil {
		switch v := err.(type) {
		case *shared.BadRequestError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for requestError returned non-nil error type *shared.BadRequestError but nil value")
			}
			res.RequestError = v
		case *shared.InternalServiceError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for internalServiceError returned non-nil error type *shared.InternalServiceError but nil value")
			}
			res.InternalServiceError = v
		default:
			return false, nil, err
		}
	} else {
		res.Success = r
	}

	return err == nil, &res, nil
}

func (s *tchanReplicatorServer) handleListExtentsStats(ctx thrift.Context, protocol athrift.TProtocol) (bool, athrift.TStruct, error) {
	var req ReplicatorListExtentsStatsArgs
	var res ReplicatorListExtentsStatsResult

	if err := req.Read(protocol); err != nil {
		return false, nil, err
	}

	r, err :=
		s.handler.ListExtentsStats(ctx, req.Request)

	if err != nil {
		switch v := err.(type) {
		case *shared.BadRequestError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for requestError returned non-nil error type *shared.BadRequestError but nil value")
			}
			res.RequestError = v
		case *shared.InternalServiceError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for internalServiceError returned non-nil error type *shared.InternalServiceError but nil value")
			}
			res.InternalServiceError = v
		default:
			return false, nil, err
		}
	} else {
		res.Success = r
	}

	return err == nil, &res, nil
}

func (s *tchanReplicatorServer) handleReadDestination(ctx thrift.Context, protocol athrift.TProtocol) (bool, athrift.TStruct, error) {
	var req ReplicatorReadDestinationArgs
	var res ReplicatorReadDestinationResult

	if err := req.Read(protocol); err != nil {
		return false, nil, err
	}

	r, err :=
		s.handler.ReadDestination(ctx, req.GetRequest)

	if err != nil {
		switch v := err.(type) {
		case *shared.EntityNotExistsError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for entityError returned non-nil error type *shared.EntityNotExistsError but nil value")
			}
			res.EntityError = v
		case *shared.BadRequestError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for requestError returned non-nil error type *shared.BadRequestError but nil value")
			}
			res.RequestError = v
		case *shared.InternalServiceError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for internalServiceError returned non-nil error type *shared.InternalServiceError but nil value")
			}
			res.InternalServiceError = v
		default:
			return false, nil, err
		}
	} else {
		res.Success = r
	}

	return err == nil, &res, nil
}

func (s *tchanReplicatorServer) handleUpdateConsumerGroup(ctx thrift.Context, protocol athrift.TProtocol) (bool, athrift.TStruct, error) {
	var req ReplicatorUpdateConsumerGroupArgs
	var res ReplicatorUpdateConsumerGroupResult

	if err := req.Read(protocol); err != nil {
		return false, nil, err
	}

	r, err :=
		s.handler.UpdateConsumerGroup(ctx, req.UpdateRequest)

	if err != nil {
		switch v := err.(type) {
		case *shared.EntityNotExistsError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for entityError returned non-nil error type *shared.EntityNotExistsError but nil value")
			}
			res.EntityError = v
		case *shared.BadRequestError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for requestError returned non-nil error type *shared.BadRequestError but nil value")
			}
			res.RequestError = v
		case *shared.InternalServiceError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for internalServiceError returned non-nil error type *shared.InternalServiceError but nil value")
			}
			res.InternalServiceError = v
		default:
			return false, nil, err
		}
	} else {
		res.Success = r
	}

	return err == nil, &res, nil
}

func (s *tchanReplicatorServer) handleUpdateDestination(ctx thrift.Context, protocol athrift.TProtocol) (bool, athrift.TStruct, error) {
	var req ReplicatorUpdateDestinationArgs
	var res ReplicatorUpdateDestinationResult

	if err := req.Read(protocol); err != nil {
		return false, nil, err
	}

	r, err :=
		s.handler.UpdateDestination(ctx, req.UpdateRequest)

	if err != nil {
		switch v := err.(type) {
		case *shared.EntityNotExistsError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for entityError returned non-nil error type *shared.EntityNotExistsError but nil value")
			}
			res.EntityError = v
		case *shared.BadRequestError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for requestError returned non-nil error type *shared.BadRequestError but nil value")
			}
			res.RequestError = v
		case *shared.InternalServiceError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for internalServiceError returned non-nil error type *shared.InternalServiceError but nil value")
			}
			res.InternalServiceError = v
		default:
			return false, nil, err
		}
	} else {
		res.Success = r
	}

	return err == nil, &res, nil
}

func (s *tchanReplicatorServer) handleUpdateRemoteConsumerGroup(ctx thrift.Context, protocol athrift.TProtocol) (bool, athrift.TStruct, error) {
	var req ReplicatorUpdateRemoteConsumerGroupArgs
	var res ReplicatorUpdateRemoteConsumerGroupResult

	if err := req.Read(protocol); err != nil {
		return false, nil, err
	}

	err :=
		s.handler.UpdateRemoteConsumerGroup(ctx, req.UpdateRequest)

	if err != nil {
		switch v := err.(type) {
		case *shared.EntityNotExistsError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for entityError returned non-nil error type *shared.EntityNotExistsError but nil value")
			}
			res.EntityError = v
		case *shared.BadRequestError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for requestError returned non-nil error type *shared.BadRequestError but nil value")
			}
			res.RequestError = v
		case *shared.InternalServiceError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for internalServiceError returned non-nil error type *shared.InternalServiceError but nil value")
			}
			res.InternalServiceError = v
		default:
			return false, nil, err
		}
	} else {
	}

	return err == nil, &res, nil
}

func (s *tchanReplicatorServer) handleUpdateRemoteDestination(ctx thrift.Context, protocol athrift.TProtocol) (bool, athrift.TStruct, error) {
	var req ReplicatorUpdateRemoteDestinationArgs
	var res ReplicatorUpdateRemoteDestinationResult

	if err := req.Read(protocol); err != nil {
		return false, nil, err
	}

	err :=
		s.handler.UpdateRemoteDestination(ctx, req.UpdateRequest)

	if err != nil {
		switch v := err.(type) {
		case *shared.EntityNotExistsError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for entityError returned non-nil error type *shared.EntityNotExistsError but nil value")
			}
			res.EntityError = v
		case *shared.BadRequestError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for requestError returned non-nil error type *shared.BadRequestError but nil value")
			}
			res.RequestError = v
		case *shared.InternalServiceError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for internalServiceError returned non-nil error type *shared.InternalServiceError but nil value")
			}
			res.InternalServiceError = v
		default:
			return false, nil, err
		}
	} else {
	}

	return err == nil, &res, nil
}
