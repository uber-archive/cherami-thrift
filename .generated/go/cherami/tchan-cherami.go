// @generated Code generated by thrift-gen. Do not modify.

// Package cherami is generated code used to make or handle TChannel calls using Thrift.
package cherami

import (
	"fmt"

	athrift "github.com/apache/thrift/lib/go/thrift"
	"github.com/uber/tchannel-go/thrift"
)

// Interfaces for the service and client for the services defined in the IDL.

// TChanBFrontend is the interface that defines the server handler and client interface.
type TChanBFrontend interface {
	HostPort(ctx thrift.Context) (string, error)
	CreateConsumerGroup(ctx thrift.Context, registerRequest *CreateConsumerGroupRequest) (*ConsumerGroupDescription, error)
	CreateDestination(ctx thrift.Context, createRequest *CreateDestinationRequest) (*DestinationDescription, error)
	DeleteConsumerGroup(ctx thrift.Context, deleteRequest *DeleteConsumerGroupRequest) error
	DeleteDestination(ctx thrift.Context, deleteRequest *DeleteDestinationRequest) error
	GetQueueDepthInfo(ctx thrift.Context, getQueueDepthInfoRequest *GetQueueDepthInfoRequest) (*GetQueueDepthInfoResult_, error)
	ListConsumerGroups(ctx thrift.Context, listRequest *ListConsumerGroupRequest) (*ListConsumerGroupResult_, error)
	ListDestinations(ctx thrift.Context, listRequest *ListDestinationsRequest) (*ListDestinationsResult_, error)
	MergeDLQForConsumerGroup(ctx thrift.Context, mergeRequest *MergeDLQForConsumerGroupRequest) error
	PurgeDLQForConsumerGroup(ctx thrift.Context, purgeRequest *PurgeDLQForConsumerGroupRequest) error
	ReadConsumerGroup(ctx thrift.Context, getRequest *ReadConsumerGroupRequest) (*ConsumerGroupDescription, error)
	ReadConsumerGroupHosts(ctx thrift.Context, getHostsRequest *ReadConsumerGroupHostsRequest) (*ReadConsumerGroupHostsResult_, error)
	ReadDestination(ctx thrift.Context, getRequest *ReadDestinationRequest) (*DestinationDescription, error)
	ReadDestinationHosts(ctx thrift.Context, getHostsRequest *ReadDestinationHostsRequest) (*ReadDestinationHostsResult_, error)
	ReadPublisherOptions(ctx thrift.Context, getPublisherOptionsRequest *ReadPublisherOptionsRequest) (*ReadPublisherOptionsResult_, error)
	UpdateConsumerGroup(ctx thrift.Context, updateRequest *UpdateConsumerGroupRequest) (*ConsumerGroupDescription, error)
	UpdateDestination(ctx thrift.Context, updateRequest *UpdateDestinationRequest) (*DestinationDescription, error)
}

// TChanBIn is the interface that defines the server handler and client interface.
type TChanBIn interface {
	PutMessageBatch(ctx thrift.Context, request *PutMessageBatchRequest) (*PutMessageBatchResult_, error)
}

// TChanBOut is the interface that defines the server handler and client interface.
type TChanBOut interface {
	AckMessages(ctx thrift.Context, ackRequest *AckMessagesRequest) error
	ReceiveMessageBatch(ctx thrift.Context, request *ReceiveMessageBatchRequest) (*ReceiveMessageBatchResult_, error)
	SetConsumedMessages(ctx thrift.Context, request *SetConsumedMessagesRequest) error
}

// Implementation of a client and service handler.

type tchanBFrontendClient struct {
	thriftService string
	client        thrift.TChanClient
}

func NewTChanBFrontendInheritedClient(thriftService string, client thrift.TChanClient) *tchanBFrontendClient {
	return &tchanBFrontendClient{
		thriftService,
		client,
	}
}

// NewTChanBFrontendClient creates a client that can be used to make remote calls.
func NewTChanBFrontendClient(client thrift.TChanClient) TChanBFrontend {
	return NewTChanBFrontendInheritedClient("BFrontend", client)
}

func (c *tchanBFrontendClient) HostPort(ctx thrift.Context) (string, error) {
	var resp BFrontendHostPortResult
	args := BFrontendHostPortArgs{}
	success, err := c.client.Call(ctx, c.thriftService, "HostPort", &args, &resp)
	if err == nil && !success {
		switch {
		default:
			err = fmt.Errorf("received no result or unknown exception for HostPort")
		}
	}

	return resp.GetSuccess(), err
}

func (c *tchanBFrontendClient) CreateConsumerGroup(ctx thrift.Context, registerRequest *CreateConsumerGroupRequest) (*ConsumerGroupDescription, error) {
	var resp BFrontendCreateConsumerGroupResult
	args := BFrontendCreateConsumerGroupArgs{
		RegisterRequest: registerRequest,
	}
	success, err := c.client.Call(ctx, c.thriftService, "createConsumerGroup", &args, &resp)
	if err == nil && !success {
		switch {
		case resp.EntityExistsError != nil:
			err = resp.EntityExistsError
		case resp.RequestError != nil:
			err = resp.RequestError
		default:
			err = fmt.Errorf("received no result or unknown exception for createConsumerGroup")
		}
	}

	return resp.GetSuccess(), err
}

func (c *tchanBFrontendClient) CreateDestination(ctx thrift.Context, createRequest *CreateDestinationRequest) (*DestinationDescription, error) {
	var resp BFrontendCreateDestinationResult
	args := BFrontendCreateDestinationArgs{
		CreateRequest: createRequest,
	}
	success, err := c.client.Call(ctx, c.thriftService, "createDestination", &args, &resp)
	if err == nil && !success {
		switch {
		case resp.EntityExistsError != nil:
			err = resp.EntityExistsError
		case resp.RequestError != nil:
			err = resp.RequestError
		default:
			err = fmt.Errorf("received no result or unknown exception for createDestination")
		}
	}

	return resp.GetSuccess(), err
}

func (c *tchanBFrontendClient) DeleteConsumerGroup(ctx thrift.Context, deleteRequest *DeleteConsumerGroupRequest) error {
	var resp BFrontendDeleteConsumerGroupResult
	args := BFrontendDeleteConsumerGroupArgs{
		DeleteRequest: deleteRequest,
	}
	success, err := c.client.Call(ctx, c.thriftService, "deleteConsumerGroup", &args, &resp)
	if err == nil && !success {
		switch {
		case resp.EntityError != nil:
			err = resp.EntityError
		case resp.RequestError != nil:
			err = resp.RequestError
		default:
			err = fmt.Errorf("received no result or unknown exception for deleteConsumerGroup")
		}
	}

	return err
}

func (c *tchanBFrontendClient) DeleteDestination(ctx thrift.Context, deleteRequest *DeleteDestinationRequest) error {
	var resp BFrontendDeleteDestinationResult
	args := BFrontendDeleteDestinationArgs{
		DeleteRequest: deleteRequest,
	}
	success, err := c.client.Call(ctx, c.thriftService, "deleteDestination", &args, &resp)
	if err == nil && !success {
		switch {
		case resp.EntityError != nil:
			err = resp.EntityError
		case resp.RequestError != nil:
			err = resp.RequestError
		default:
			err = fmt.Errorf("received no result or unknown exception for deleteDestination")
		}
	}

	return err
}

func (c *tchanBFrontendClient) GetQueueDepthInfo(ctx thrift.Context, getQueueDepthInfoRequest *GetQueueDepthInfoRequest) (*GetQueueDepthInfoResult_, error) {
	var resp BFrontendGetQueueDepthInfoResult
	args := BFrontendGetQueueDepthInfoArgs{
		GetQueueDepthInfoRequest: getQueueDepthInfoRequest,
	}
	success, err := c.client.Call(ctx, c.thriftService, "getQueueDepthInfo", &args, &resp)
	if err == nil && !success {
		switch {
		case resp.CacheMissError != nil:
			err = resp.CacheMissError
		case resp.RequestError != nil:
			err = resp.RequestError
		default:
			err = fmt.Errorf("received no result or unknown exception for getQueueDepthInfo")
		}
	}

	return resp.GetSuccess(), err
}

func (c *tchanBFrontendClient) ListConsumerGroups(ctx thrift.Context, listRequest *ListConsumerGroupRequest) (*ListConsumerGroupResult_, error) {
	var resp BFrontendListConsumerGroupsResult
	args := BFrontendListConsumerGroupsArgs{
		ListRequest: listRequest,
	}
	success, err := c.client.Call(ctx, c.thriftService, "listConsumerGroups", &args, &resp)
	if err == nil && !success {
		switch {
		case resp.RequestError != nil:
			err = resp.RequestError
		default:
			err = fmt.Errorf("received no result or unknown exception for listConsumerGroups")
		}
	}

	return resp.GetSuccess(), err
}

func (c *tchanBFrontendClient) ListDestinations(ctx thrift.Context, listRequest *ListDestinationsRequest) (*ListDestinationsResult_, error) {
	var resp BFrontendListDestinationsResult
	args := BFrontendListDestinationsArgs{
		ListRequest: listRequest,
	}
	success, err := c.client.Call(ctx, c.thriftService, "listDestinations", &args, &resp)
	if err == nil && !success {
		switch {
		case resp.RequestError != nil:
			err = resp.RequestError
		default:
			err = fmt.Errorf("received no result or unknown exception for listDestinations")
		}
	}

	return resp.GetSuccess(), err
}

func (c *tchanBFrontendClient) MergeDLQForConsumerGroup(ctx thrift.Context, mergeRequest *MergeDLQForConsumerGroupRequest) error {
	var resp BFrontendMergeDLQForConsumerGroupResult
	args := BFrontendMergeDLQForConsumerGroupArgs{
		MergeRequest: mergeRequest,
	}
	success, err := c.client.Call(ctx, c.thriftService, "mergeDLQForConsumerGroup", &args, &resp)
	if err == nil && !success {
		switch {
		case resp.EntityError != nil:
			err = resp.EntityError
		case resp.RequestError != nil:
			err = resp.RequestError
		default:
			err = fmt.Errorf("received no result or unknown exception for mergeDLQForConsumerGroup")
		}
	}

	return err
}

func (c *tchanBFrontendClient) PurgeDLQForConsumerGroup(ctx thrift.Context, purgeRequest *PurgeDLQForConsumerGroupRequest) error {
	var resp BFrontendPurgeDLQForConsumerGroupResult
	args := BFrontendPurgeDLQForConsumerGroupArgs{
		PurgeRequest: purgeRequest,
	}
	success, err := c.client.Call(ctx, c.thriftService, "purgeDLQForConsumerGroup", &args, &resp)
	if err == nil && !success {
		switch {
		case resp.EntityError != nil:
			err = resp.EntityError
		case resp.RequestError != nil:
			err = resp.RequestError
		default:
			err = fmt.Errorf("received no result or unknown exception for purgeDLQForConsumerGroup")
		}
	}

	return err
}

func (c *tchanBFrontendClient) ReadConsumerGroup(ctx thrift.Context, getRequest *ReadConsumerGroupRequest) (*ConsumerGroupDescription, error) {
	var resp BFrontendReadConsumerGroupResult
	args := BFrontendReadConsumerGroupArgs{
		GetRequest: getRequest,
	}
	success, err := c.client.Call(ctx, c.thriftService, "readConsumerGroup", &args, &resp)
	if err == nil && !success {
		switch {
		case resp.EntityError != nil:
			err = resp.EntityError
		case resp.RequestError != nil:
			err = resp.RequestError
		default:
			err = fmt.Errorf("received no result or unknown exception for readConsumerGroup")
		}
	}

	return resp.GetSuccess(), err
}

func (c *tchanBFrontendClient) ReadConsumerGroupHosts(ctx thrift.Context, getHostsRequest *ReadConsumerGroupHostsRequest) (*ReadConsumerGroupHostsResult_, error) {
	var resp BFrontendReadConsumerGroupHostsResult
	args := BFrontendReadConsumerGroupHostsArgs{
		GetHostsRequest: getHostsRequest,
	}
	success, err := c.client.Call(ctx, c.thriftService, "readConsumerGroupHosts", &args, &resp)
	if err == nil && !success {
		switch {
		case resp.EntityError != nil:
			err = resp.EntityError
		case resp.EntityDisabled != nil:
			err = resp.EntityDisabled
		case resp.RequestError != nil:
			err = resp.RequestError
		default:
			err = fmt.Errorf("received no result or unknown exception for readConsumerGroupHosts")
		}
	}

	return resp.GetSuccess(), err
}

func (c *tchanBFrontendClient) ReadDestination(ctx thrift.Context, getRequest *ReadDestinationRequest) (*DestinationDescription, error) {
	var resp BFrontendReadDestinationResult
	args := BFrontendReadDestinationArgs{
		GetRequest: getRequest,
	}
	success, err := c.client.Call(ctx, c.thriftService, "readDestination", &args, &resp)
	if err == nil && !success {
		switch {
		case resp.EntityError != nil:
			err = resp.EntityError
		case resp.RequestError != nil:
			err = resp.RequestError
		default:
			err = fmt.Errorf("received no result or unknown exception for readDestination")
		}
	}

	return resp.GetSuccess(), err
}

func (c *tchanBFrontendClient) ReadDestinationHosts(ctx thrift.Context, getHostsRequest *ReadDestinationHostsRequest) (*ReadDestinationHostsResult_, error) {
	var resp BFrontendReadDestinationHostsResult
	args := BFrontendReadDestinationHostsArgs{
		GetHostsRequest: getHostsRequest,
	}
	success, err := c.client.Call(ctx, c.thriftService, "readDestinationHosts", &args, &resp)
	if err == nil && !success {
		switch {
		case resp.EntityError != nil:
			err = resp.EntityError
		case resp.EntityDisabled != nil:
			err = resp.EntityDisabled
		case resp.RequestError != nil:
			err = resp.RequestError
		default:
			err = fmt.Errorf("received no result or unknown exception for readDestinationHosts")
		}
	}

	return resp.GetSuccess(), err
}

func (c *tchanBFrontendClient) ReadPublisherOptions(ctx thrift.Context, getPublisherOptionsRequest *ReadPublisherOptionsRequest) (*ReadPublisherOptionsResult_, error) {
	var resp BFrontendReadPublisherOptionsResult
	args := BFrontendReadPublisherOptionsArgs{
		GetPublisherOptionsRequest: getPublisherOptionsRequest,
	}
	success, err := c.client.Call(ctx, c.thriftService, "readPublisherOptions", &args, &resp)
	if err == nil && !success {
		switch {
		case resp.EntityError != nil:
			err = resp.EntityError
		case resp.EntityDisabled != nil:
			err = resp.EntityDisabled
		case resp.RequestError != nil:
			err = resp.RequestError
		default:
			err = fmt.Errorf("received no result or unknown exception for readPublisherOptions")
		}
	}

	return resp.GetSuccess(), err
}

func (c *tchanBFrontendClient) UpdateConsumerGroup(ctx thrift.Context, updateRequest *UpdateConsumerGroupRequest) (*ConsumerGroupDescription, error) {
	var resp BFrontendUpdateConsumerGroupResult
	args := BFrontendUpdateConsumerGroupArgs{
		UpdateRequest: updateRequest,
	}
	success, err := c.client.Call(ctx, c.thriftService, "updateConsumerGroup", &args, &resp)
	if err == nil && !success {
		switch {
		case resp.EntityError != nil:
			err = resp.EntityError
		case resp.RequestError != nil:
			err = resp.RequestError
		default:
			err = fmt.Errorf("received no result or unknown exception for updateConsumerGroup")
		}
	}

	return resp.GetSuccess(), err
}

func (c *tchanBFrontendClient) UpdateDestination(ctx thrift.Context, updateRequest *UpdateDestinationRequest) (*DestinationDescription, error) {
	var resp BFrontendUpdateDestinationResult
	args := BFrontendUpdateDestinationArgs{
		UpdateRequest: updateRequest,
	}
	success, err := c.client.Call(ctx, c.thriftService, "updateDestination", &args, &resp)
	if err == nil && !success {
		switch {
		case resp.EntityError != nil:
			err = resp.EntityError
		case resp.RequestError != nil:
			err = resp.RequestError
		default:
			err = fmt.Errorf("received no result or unknown exception for updateDestination")
		}
	}

	return resp.GetSuccess(), err
}

type tchanBFrontendServer struct {
	handler TChanBFrontend
}

// NewTChanBFrontendServer wraps a handler for TChanBFrontend so it can be
// registered with a thrift.Server.
func NewTChanBFrontendServer(handler TChanBFrontend) thrift.TChanServer {
	return &tchanBFrontendServer{
		handler,
	}
}

func (s *tchanBFrontendServer) Service() string {
	return "BFrontend"
}

func (s *tchanBFrontendServer) Methods() []string {
	return []string{
		"HostPort",
		"createConsumerGroup",
		"createDestination",
		"deleteConsumerGroup",
		"deleteDestination",
		"getQueueDepthInfo",
		"listConsumerGroups",
		"listDestinations",
		"mergeDLQForConsumerGroup",
		"purgeDLQForConsumerGroup",
		"readConsumerGroup",
		"readConsumerGroupHosts",
		"readDestination",
		"readDestinationHosts",
		"readPublisherOptions",
		"updateConsumerGroup",
		"updateDestination",
	}
}

func (s *tchanBFrontendServer) Handle(ctx thrift.Context, methodName string, protocol athrift.TProtocol) (bool, athrift.TStruct, error) {
	switch methodName {
	case "HostPort":
		return s.handleHostPort(ctx, protocol)
	case "createConsumerGroup":
		return s.handleCreateConsumerGroup(ctx, protocol)
	case "createDestination":
		return s.handleCreateDestination(ctx, protocol)
	case "deleteConsumerGroup":
		return s.handleDeleteConsumerGroup(ctx, protocol)
	case "deleteDestination":
		return s.handleDeleteDestination(ctx, protocol)
	case "getQueueDepthInfo":
		return s.handleGetQueueDepthInfo(ctx, protocol)
	case "listConsumerGroups":
		return s.handleListConsumerGroups(ctx, protocol)
	case "listDestinations":
		return s.handleListDestinations(ctx, protocol)
	case "mergeDLQForConsumerGroup":
		return s.handleMergeDLQForConsumerGroup(ctx, protocol)
	case "purgeDLQForConsumerGroup":
		return s.handlePurgeDLQForConsumerGroup(ctx, protocol)
	case "readConsumerGroup":
		return s.handleReadConsumerGroup(ctx, protocol)
	case "readConsumerGroupHosts":
		return s.handleReadConsumerGroupHosts(ctx, protocol)
	case "readDestination":
		return s.handleReadDestination(ctx, protocol)
	case "readDestinationHosts":
		return s.handleReadDestinationHosts(ctx, protocol)
	case "readPublisherOptions":
		return s.handleReadPublisherOptions(ctx, protocol)
	case "updateConsumerGroup":
		return s.handleUpdateConsumerGroup(ctx, protocol)
	case "updateDestination":
		return s.handleUpdateDestination(ctx, protocol)

	default:
		return false, nil, fmt.Errorf("method %v not found in service %v", methodName, s.Service())
	}
}

func (s *tchanBFrontendServer) handleHostPort(ctx thrift.Context, protocol athrift.TProtocol) (bool, athrift.TStruct, error) {
	var req BFrontendHostPortArgs
	var res BFrontendHostPortResult

	if err := req.Read(protocol); err != nil {
		return false, nil, err
	}

	r, err :=
		s.handler.HostPort(ctx)

	if err != nil {
		return false, nil, err
	} else {
		res.Success = &r
	}

	return err == nil, &res, nil
}

func (s *tchanBFrontendServer) handleCreateConsumerGroup(ctx thrift.Context, protocol athrift.TProtocol) (bool, athrift.TStruct, error) {
	var req BFrontendCreateConsumerGroupArgs
	var res BFrontendCreateConsumerGroupResult

	if err := req.Read(protocol); err != nil {
		return false, nil, err
	}

	r, err :=
		s.handler.CreateConsumerGroup(ctx, req.RegisterRequest)

	if err != nil {
		switch v := err.(type) {
		case *EntityAlreadyExistsError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for entityExistsError returned non-nil error type *EntityAlreadyExistsError but nil value")
			}
			res.EntityExistsError = v
		case *BadRequestError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for requestError returned non-nil error type *BadRequestError but nil value")
			}
			res.RequestError = v
		default:
			return false, nil, err
		}
	} else {
		res.Success = r
	}

	return err == nil, &res, nil
}

func (s *tchanBFrontendServer) handleCreateDestination(ctx thrift.Context, protocol athrift.TProtocol) (bool, athrift.TStruct, error) {
	var req BFrontendCreateDestinationArgs
	var res BFrontendCreateDestinationResult

	if err := req.Read(protocol); err != nil {
		return false, nil, err
	}

	r, err :=
		s.handler.CreateDestination(ctx, req.CreateRequest)

	if err != nil {
		switch v := err.(type) {
		case *EntityAlreadyExistsError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for entityExistsError returned non-nil error type *EntityAlreadyExistsError but nil value")
			}
			res.EntityExistsError = v
		case *BadRequestError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for requestError returned non-nil error type *BadRequestError but nil value")
			}
			res.RequestError = v
		default:
			return false, nil, err
		}
	} else {
		res.Success = r
	}

	return err == nil, &res, nil
}

func (s *tchanBFrontendServer) handleDeleteConsumerGroup(ctx thrift.Context, protocol athrift.TProtocol) (bool, athrift.TStruct, error) {
	var req BFrontendDeleteConsumerGroupArgs
	var res BFrontendDeleteConsumerGroupResult

	if err := req.Read(protocol); err != nil {
		return false, nil, err
	}

	err :=
		s.handler.DeleteConsumerGroup(ctx, req.DeleteRequest)

	if err != nil {
		switch v := err.(type) {
		case *EntityNotExistsError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for entityError returned non-nil error type *EntityNotExistsError but nil value")
			}
			res.EntityError = v
		case *BadRequestError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for requestError returned non-nil error type *BadRequestError but nil value")
			}
			res.RequestError = v
		default:
			return false, nil, err
		}
	} else {
	}

	return err == nil, &res, nil
}

func (s *tchanBFrontendServer) handleDeleteDestination(ctx thrift.Context, protocol athrift.TProtocol) (bool, athrift.TStruct, error) {
	var req BFrontendDeleteDestinationArgs
	var res BFrontendDeleteDestinationResult

	if err := req.Read(protocol); err != nil {
		return false, nil, err
	}

	err :=
		s.handler.DeleteDestination(ctx, req.DeleteRequest)

	if err != nil {
		switch v := err.(type) {
		case *EntityNotExistsError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for entityError returned non-nil error type *EntityNotExistsError but nil value")
			}
			res.EntityError = v
		case *BadRequestError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for requestError returned non-nil error type *BadRequestError but nil value")
			}
			res.RequestError = v
		default:
			return false, nil, err
		}
	} else {
	}

	return err == nil, &res, nil
}

func (s *tchanBFrontendServer) handleGetQueueDepthInfo(ctx thrift.Context, protocol athrift.TProtocol) (bool, athrift.TStruct, error) {
	var req BFrontendGetQueueDepthInfoArgs
	var res BFrontendGetQueueDepthInfoResult

	if err := req.Read(protocol); err != nil {
		return false, nil, err
	}

	r, err :=
		s.handler.GetQueueDepthInfo(ctx, req.GetQueueDepthInfoRequest)

	if err != nil {
		switch v := err.(type) {
		case *QueueCacheMissError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for cacheMissError returned non-nil error type *QueueCacheMissError but nil value")
			}
			res.CacheMissError = v
		case *BadRequestError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for requestError returned non-nil error type *BadRequestError but nil value")
			}
			res.RequestError = v
		default:
			return false, nil, err
		}
	} else {
		res.Success = r
	}

	return err == nil, &res, nil
}

func (s *tchanBFrontendServer) handleListConsumerGroups(ctx thrift.Context, protocol athrift.TProtocol) (bool, athrift.TStruct, error) {
	var req BFrontendListConsumerGroupsArgs
	var res BFrontendListConsumerGroupsResult

	if err := req.Read(protocol); err != nil {
		return false, nil, err
	}

	r, err :=
		s.handler.ListConsumerGroups(ctx, req.ListRequest)

	if err != nil {
		switch v := err.(type) {
		case *BadRequestError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for requestError returned non-nil error type *BadRequestError but nil value")
			}
			res.RequestError = v
		default:
			return false, nil, err
		}
	} else {
		res.Success = r
	}

	return err == nil, &res, nil
}

func (s *tchanBFrontendServer) handleListDestinations(ctx thrift.Context, protocol athrift.TProtocol) (bool, athrift.TStruct, error) {
	var req BFrontendListDestinationsArgs
	var res BFrontendListDestinationsResult

	if err := req.Read(protocol); err != nil {
		return false, nil, err
	}

	r, err :=
		s.handler.ListDestinations(ctx, req.ListRequest)

	if err != nil {
		switch v := err.(type) {
		case *BadRequestError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for requestError returned non-nil error type *BadRequestError but nil value")
			}
			res.RequestError = v
		default:
			return false, nil, err
		}
	} else {
		res.Success = r
	}

	return err == nil, &res, nil
}

func (s *tchanBFrontendServer) handleMergeDLQForConsumerGroup(ctx thrift.Context, protocol athrift.TProtocol) (bool, athrift.TStruct, error) {
	var req BFrontendMergeDLQForConsumerGroupArgs
	var res BFrontendMergeDLQForConsumerGroupResult

	if err := req.Read(protocol); err != nil {
		return false, nil, err
	}

	err :=
		s.handler.MergeDLQForConsumerGroup(ctx, req.MergeRequest)

	if err != nil {
		switch v := err.(type) {
		case *EntityNotExistsError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for entityError returned non-nil error type *EntityNotExistsError but nil value")
			}
			res.EntityError = v
		case *BadRequestError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for requestError returned non-nil error type *BadRequestError but nil value")
			}
			res.RequestError = v
		default:
			return false, nil, err
		}
	} else {
	}

	return err == nil, &res, nil
}

func (s *tchanBFrontendServer) handlePurgeDLQForConsumerGroup(ctx thrift.Context, protocol athrift.TProtocol) (bool, athrift.TStruct, error) {
	var req BFrontendPurgeDLQForConsumerGroupArgs
	var res BFrontendPurgeDLQForConsumerGroupResult

	if err := req.Read(protocol); err != nil {
		return false, nil, err
	}

	err :=
		s.handler.PurgeDLQForConsumerGroup(ctx, req.PurgeRequest)

	if err != nil {
		switch v := err.(type) {
		case *EntityNotExistsError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for entityError returned non-nil error type *EntityNotExistsError but nil value")
			}
			res.EntityError = v
		case *BadRequestError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for requestError returned non-nil error type *BadRequestError but nil value")
			}
			res.RequestError = v
		default:
			return false, nil, err
		}
	} else {
	}

	return err == nil, &res, nil
}

func (s *tchanBFrontendServer) handleReadConsumerGroup(ctx thrift.Context, protocol athrift.TProtocol) (bool, athrift.TStruct, error) {
	var req BFrontendReadConsumerGroupArgs
	var res BFrontendReadConsumerGroupResult

	if err := req.Read(protocol); err != nil {
		return false, nil, err
	}

	r, err :=
		s.handler.ReadConsumerGroup(ctx, req.GetRequest)

	if err != nil {
		switch v := err.(type) {
		case *EntityNotExistsError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for entityError returned non-nil error type *EntityNotExistsError but nil value")
			}
			res.EntityError = v
		case *BadRequestError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for requestError returned non-nil error type *BadRequestError but nil value")
			}
			res.RequestError = v
		default:
			return false, nil, err
		}
	} else {
		res.Success = r
	}

	return err == nil, &res, nil
}

func (s *tchanBFrontendServer) handleReadConsumerGroupHosts(ctx thrift.Context, protocol athrift.TProtocol) (bool, athrift.TStruct, error) {
	var req BFrontendReadConsumerGroupHostsArgs
	var res BFrontendReadConsumerGroupHostsResult

	if err := req.Read(protocol); err != nil {
		return false, nil, err
	}

	r, err :=
		s.handler.ReadConsumerGroupHosts(ctx, req.GetHostsRequest)

	if err != nil {
		switch v := err.(type) {
		case *EntityNotExistsError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for entityError returned non-nil error type *EntityNotExistsError but nil value")
			}
			res.EntityError = v
		case *EntityDisabledError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for entityDisabled returned non-nil error type *EntityDisabledError but nil value")
			}
			res.EntityDisabled = v
		case *BadRequestError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for requestError returned non-nil error type *BadRequestError but nil value")
			}
			res.RequestError = v
		default:
			return false, nil, err
		}
	} else {
		res.Success = r
	}

	return err == nil, &res, nil
}

func (s *tchanBFrontendServer) handleReadDestination(ctx thrift.Context, protocol athrift.TProtocol) (bool, athrift.TStruct, error) {
	var req BFrontendReadDestinationArgs
	var res BFrontendReadDestinationResult

	if err := req.Read(protocol); err != nil {
		return false, nil, err
	}

	r, err :=
		s.handler.ReadDestination(ctx, req.GetRequest)

	if err != nil {
		switch v := err.(type) {
		case *EntityNotExistsError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for entityError returned non-nil error type *EntityNotExistsError but nil value")
			}
			res.EntityError = v
		case *BadRequestError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for requestError returned non-nil error type *BadRequestError but nil value")
			}
			res.RequestError = v
		default:
			return false, nil, err
		}
	} else {
		res.Success = r
	}

	return err == nil, &res, nil
}

func (s *tchanBFrontendServer) handleReadDestinationHosts(ctx thrift.Context, protocol athrift.TProtocol) (bool, athrift.TStruct, error) {
	var req BFrontendReadDestinationHostsArgs
	var res BFrontendReadDestinationHostsResult

	if err := req.Read(protocol); err != nil {
		return false, nil, err
	}

	r, err :=
		s.handler.ReadDestinationHosts(ctx, req.GetHostsRequest)

	if err != nil {
		switch v := err.(type) {
		case *EntityNotExistsError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for entityError returned non-nil error type *EntityNotExistsError but nil value")
			}
			res.EntityError = v
		case *EntityDisabledError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for entityDisabled returned non-nil error type *EntityDisabledError but nil value")
			}
			res.EntityDisabled = v
		case *BadRequestError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for requestError returned non-nil error type *BadRequestError but nil value")
			}
			res.RequestError = v
		default:
			return false, nil, err
		}
	} else {
		res.Success = r
	}

	return err == nil, &res, nil
}

func (s *tchanBFrontendServer) handleReadPublisherOptions(ctx thrift.Context, protocol athrift.TProtocol) (bool, athrift.TStruct, error) {
	var req BFrontendReadPublisherOptionsArgs
	var res BFrontendReadPublisherOptionsResult

	if err := req.Read(protocol); err != nil {
		return false, nil, err
	}

	r, err :=
		s.handler.ReadPublisherOptions(ctx, req.GetPublisherOptionsRequest)

	if err != nil {
		switch v := err.(type) {
		case *EntityNotExistsError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for entityError returned non-nil error type *EntityNotExistsError but nil value")
			}
			res.EntityError = v
		case *EntityDisabledError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for entityDisabled returned non-nil error type *EntityDisabledError but nil value")
			}
			res.EntityDisabled = v
		case *BadRequestError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for requestError returned non-nil error type *BadRequestError but nil value")
			}
			res.RequestError = v
		default:
			return false, nil, err
		}
	} else {
		res.Success = r
	}

	return err == nil, &res, nil
}

func (s *tchanBFrontendServer) handleUpdateConsumerGroup(ctx thrift.Context, protocol athrift.TProtocol) (bool, athrift.TStruct, error) {
	var req BFrontendUpdateConsumerGroupArgs
	var res BFrontendUpdateConsumerGroupResult

	if err := req.Read(protocol); err != nil {
		return false, nil, err
	}

	r, err :=
		s.handler.UpdateConsumerGroup(ctx, req.UpdateRequest)

	if err != nil {
		switch v := err.(type) {
		case *EntityNotExistsError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for entityError returned non-nil error type *EntityNotExistsError but nil value")
			}
			res.EntityError = v
		case *BadRequestError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for requestError returned non-nil error type *BadRequestError but nil value")
			}
			res.RequestError = v
		default:
			return false, nil, err
		}
	} else {
		res.Success = r
	}

	return err == nil, &res, nil
}

func (s *tchanBFrontendServer) handleUpdateDestination(ctx thrift.Context, protocol athrift.TProtocol) (bool, athrift.TStruct, error) {
	var req BFrontendUpdateDestinationArgs
	var res BFrontendUpdateDestinationResult

	if err := req.Read(protocol); err != nil {
		return false, nil, err
	}

	r, err :=
		s.handler.UpdateDestination(ctx, req.UpdateRequest)

	if err != nil {
		switch v := err.(type) {
		case *EntityNotExistsError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for entityError returned non-nil error type *EntityNotExistsError but nil value")
			}
			res.EntityError = v
		case *BadRequestError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for requestError returned non-nil error type *BadRequestError but nil value")
			}
			res.RequestError = v
		default:
			return false, nil, err
		}
	} else {
		res.Success = r
	}

	return err == nil, &res, nil
}

type tchanBInClient struct {
	thriftService string
	client        thrift.TChanClient
}

func NewTChanBInInheritedClient(thriftService string, client thrift.TChanClient) *tchanBInClient {
	return &tchanBInClient{
		thriftService,
		client,
	}
}

// NewTChanBInClient creates a client that can be used to make remote calls.
func NewTChanBInClient(client thrift.TChanClient) TChanBIn {
	return NewTChanBInInheritedClient("BIn", client)
}

func (c *tchanBInClient) PutMessageBatch(ctx thrift.Context, request *PutMessageBatchRequest) (*PutMessageBatchResult_, error) {
	var resp BInPutMessageBatchResult
	args := BInPutMessageBatchArgs{
		Request: request,
	}
	success, err := c.client.Call(ctx, c.thriftService, "putMessageBatch", &args, &resp)
	if err == nil && !success {
		switch {
		case resp.EntityError != nil:
			err = resp.EntityError
		case resp.EntityDisabled != nil:
			err = resp.EntityDisabled
		case resp.RequestError != nil:
			err = resp.RequestError
		case resp.InternalServiceError != nil:
			err = resp.InternalServiceError
		default:
			err = fmt.Errorf("received no result or unknown exception for putMessageBatch")
		}
	}

	return resp.GetSuccess(), err
}

type tchanBInServer struct {
	handler TChanBIn
}

// NewTChanBInServer wraps a handler for TChanBIn so it can be
// registered with a thrift.Server.
func NewTChanBInServer(handler TChanBIn) thrift.TChanServer {
	return &tchanBInServer{
		handler,
	}
}

func (s *tchanBInServer) Service() string {
	return "BIn"
}

func (s *tchanBInServer) Methods() []string {
	return []string{
		"putMessageBatch",
	}
}

func (s *tchanBInServer) Handle(ctx thrift.Context, methodName string, protocol athrift.TProtocol) (bool, athrift.TStruct, error) {
	switch methodName {
	case "putMessageBatch":
		return s.handlePutMessageBatch(ctx, protocol)

	default:
		return false, nil, fmt.Errorf("method %v not found in service %v", methodName, s.Service())
	}
}

func (s *tchanBInServer) handlePutMessageBatch(ctx thrift.Context, protocol athrift.TProtocol) (bool, athrift.TStruct, error) {
	var req BInPutMessageBatchArgs
	var res BInPutMessageBatchResult

	if err := req.Read(protocol); err != nil {
		return false, nil, err
	}

	r, err :=
		s.handler.PutMessageBatch(ctx, req.Request)

	if err != nil {
		switch v := err.(type) {
		case *EntityNotExistsError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for entityError returned non-nil error type *EntityNotExistsError but nil value")
			}
			res.EntityError = v
		case *EntityDisabledError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for entityDisabled returned non-nil error type *EntityDisabledError but nil value")
			}
			res.EntityDisabled = v
		case *BadRequestError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for requestError returned non-nil error type *BadRequestError but nil value")
			}
			res.RequestError = v
		case *InternalServiceError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for internalServiceError returned non-nil error type *InternalServiceError but nil value")
			}
			res.InternalServiceError = v
		default:
			return false, nil, err
		}
	} else {
		res.Success = r
	}

	return err == nil, &res, nil
}

type tchanBOutClient struct {
	thriftService string
	client        thrift.TChanClient
}

func NewTChanBOutInheritedClient(thriftService string, client thrift.TChanClient) *tchanBOutClient {
	return &tchanBOutClient{
		thriftService,
		client,
	}
}

// NewTChanBOutClient creates a client that can be used to make remote calls.
func NewTChanBOutClient(client thrift.TChanClient) TChanBOut {
	return NewTChanBOutInheritedClient("BOut", client)
}

func (c *tchanBOutClient) AckMessages(ctx thrift.Context, ackRequest *AckMessagesRequest) error {
	var resp BOutAckMessagesResult
	args := BOutAckMessagesArgs{
		AckRequest: ackRequest,
	}
	success, err := c.client.Call(ctx, c.thriftService, "ackMessages", &args, &resp)
	if err == nil && !success {
		switch {
		case resp.EntityError != nil:
			err = resp.EntityError
		case resp.RequestError != nil:
			err = resp.RequestError
		default:
			err = fmt.Errorf("received no result or unknown exception for ackMessages")
		}
	}

	return err
}

func (c *tchanBOutClient) ReceiveMessageBatch(ctx thrift.Context, request *ReceiveMessageBatchRequest) (*ReceiveMessageBatchResult_, error) {
	var resp BOutReceiveMessageBatchResult
	args := BOutReceiveMessageBatchArgs{
		Request: request,
	}
	success, err := c.client.Call(ctx, c.thriftService, "receiveMessageBatch", &args, &resp)
	if err == nil && !success {
		switch {
		case resp.EntityError != nil:
			err = resp.EntityError
		case resp.EntityDisabled != nil:
			err = resp.EntityDisabled
		case resp.RequestError != nil:
			err = resp.RequestError
		case resp.TimeoutError != nil:
			err = resp.TimeoutError
		default:
			err = fmt.Errorf("received no result or unknown exception for receiveMessageBatch")
		}
	}

	return resp.GetSuccess(), err
}

func (c *tchanBOutClient) SetConsumedMessages(ctx thrift.Context, request *SetConsumedMessagesRequest) error {
	var resp BOutSetConsumedMessagesResult
	args := BOutSetConsumedMessagesArgs{
		Request: request,
	}
	success, err := c.client.Call(ctx, c.thriftService, "setConsumedMessages", &args, &resp)
	if err == nil && !success {
		switch {
		case resp.EntityError != nil:
			err = resp.EntityError
		case resp.RequestError != nil:
			err = resp.RequestError
		default:
			err = fmt.Errorf("received no result or unknown exception for setConsumedMessages")
		}
	}

	return err
}

type tchanBOutServer struct {
	handler TChanBOut
}

// NewTChanBOutServer wraps a handler for TChanBOut so it can be
// registered with a thrift.Server.
func NewTChanBOutServer(handler TChanBOut) thrift.TChanServer {
	return &tchanBOutServer{
		handler,
	}
}

func (s *tchanBOutServer) Service() string {
	return "BOut"
}

func (s *tchanBOutServer) Methods() []string {
	return []string{
		"ackMessages",
		"receiveMessageBatch",
		"setConsumedMessages",
	}
}

func (s *tchanBOutServer) Handle(ctx thrift.Context, methodName string, protocol athrift.TProtocol) (bool, athrift.TStruct, error) {
	switch methodName {
	case "ackMessages":
		return s.handleAckMessages(ctx, protocol)
	case "receiveMessageBatch":
		return s.handleReceiveMessageBatch(ctx, protocol)
	case "setConsumedMessages":
		return s.handleSetConsumedMessages(ctx, protocol)

	default:
		return false, nil, fmt.Errorf("method %v not found in service %v", methodName, s.Service())
	}
}

func (s *tchanBOutServer) handleAckMessages(ctx thrift.Context, protocol athrift.TProtocol) (bool, athrift.TStruct, error) {
	var req BOutAckMessagesArgs
	var res BOutAckMessagesResult

	if err := req.Read(protocol); err != nil {
		return false, nil, err
	}

	err :=
		s.handler.AckMessages(ctx, req.AckRequest)

	if err != nil {
		switch v := err.(type) {
		case *InvalidAckIdError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for entityError returned non-nil error type *InvalidAckIdError but nil value")
			}
			res.EntityError = v
		case *BadRequestError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for requestError returned non-nil error type *BadRequestError but nil value")
			}
			res.RequestError = v
		default:
			return false, nil, err
		}
	} else {
	}

	return err == nil, &res, nil
}

func (s *tchanBOutServer) handleReceiveMessageBatch(ctx thrift.Context, protocol athrift.TProtocol) (bool, athrift.TStruct, error) {
	var req BOutReceiveMessageBatchArgs
	var res BOutReceiveMessageBatchResult

	if err := req.Read(protocol); err != nil {
		return false, nil, err
	}

	r, err :=
		s.handler.ReceiveMessageBatch(ctx, req.Request)

	if err != nil {
		switch v := err.(type) {
		case *EntityNotExistsError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for entityError returned non-nil error type *EntityNotExistsError but nil value")
			}
			res.EntityError = v
		case *EntityDisabledError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for entityDisabled returned non-nil error type *EntityDisabledError but nil value")
			}
			res.EntityDisabled = v
		case *BadRequestError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for requestError returned non-nil error type *BadRequestError but nil value")
			}
			res.RequestError = v
		case *TimeoutError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for timeoutError returned non-nil error type *TimeoutError but nil value")
			}
			res.TimeoutError = v
		default:
			return false, nil, err
		}
	} else {
		res.Success = r
	}

	return err == nil, &res, nil
}

func (s *tchanBOutServer) handleSetConsumedMessages(ctx thrift.Context, protocol athrift.TProtocol) (bool, athrift.TStruct, error) {
	var req BOutSetConsumedMessagesArgs
	var res BOutSetConsumedMessagesResult

	if err := req.Read(protocol); err != nil {
		return false, nil, err
	}

	err :=
		s.handler.SetConsumedMessages(ctx, req.Request)

	if err != nil {
		switch v := err.(type) {
		case *InvalidAddressError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for entityError returned non-nil error type *InvalidAddressError but nil value")
			}
			res.EntityError = v
		case *BadRequestError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for requestError returned non-nil error type *BadRequestError but nil value")
			}
			res.RequestError = v
		default:
			return false, nil, err
		}
	} else {
	}

	return err == nil, &res, nil
}
