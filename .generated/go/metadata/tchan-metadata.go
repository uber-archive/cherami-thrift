// @generated Code generated by thrift-gen. Do not modify.

// Package metadata is generated code used to make or handle TChannel calls using Thrift.
package metadata

import (
	"fmt"

	athrift "github.com/apache/thrift/lib/go/thrift"
	"github.com/uber/tchannel-go/thrift"

	"github.com/uber/cherami-thrift/.generated/go/shared"
)

var _ = shared.GoUnusedProtection__

// Interfaces for the service and client for the services defined in the IDL.

// TChanMetadataExposable is the interface that defines the server handler and client interface.
type TChanMetadataExposable interface {
	ListEntityOps(ctx thrift.Context, listRequest *ListEntityOpsRequest) (*ListEntityOpsResult_, error)
	CreateServiceConfig(ctx thrift.Context, request *CreateServiceConfigRequest) error
	DeleteServiceConfig(ctx thrift.Context, request *DeleteServiceConfigRequest) error
	HostAddrToUUID(ctx thrift.Context, hostAddr string) (string, error)
	ListAllConsumerGroups(ctx thrift.Context, listRequest *ListConsumerGroupRequest) (*ListConsumerGroupResult_, error)
	ListConsumerGroups(ctx thrift.Context, listRequest *ListConsumerGroupRequest) (*ListConsumerGroupResult_, error)
	ListDestinations(ctx thrift.Context, listRequest *shared.ListDestinationsRequest) (*shared.ListDestinationsResult_, error)
	ListDestinationsByUUID(ctx thrift.Context, listRequest *shared.ListDestinationsByUUIDRequest) (*shared.ListDestinationsResult_, error)
	ListExtentsStats(ctx thrift.Context, request *shared.ListExtentsStatsRequest) (*shared.ListExtentsStatsResult_, error)
	ListHosts(ctx thrift.Context, request *ListHostsRequest) (*ListHostsResult_, error)
	ListInputHostExtentsStats(ctx thrift.Context, request *ListInputHostExtentsStatsRequest) (*ListInputHostExtentsStatsResult_, error)
	ListStoreExtentsStats(ctx thrift.Context, request *ListStoreExtentsStatsRequest) (*ListStoreExtentsStatsResult_, error)
	ReadConsumerGroup(ctx thrift.Context, getRequest *ReadConsumerGroupRequest) (*shared.ConsumerGroupDescription, error)
	ReadConsumerGroupByUUID(ctx thrift.Context, request *ReadConsumerGroupRequest) (*shared.ConsumerGroupDescription, error)
	ReadConsumerGroupExtent(ctx thrift.Context, request *ReadConsumerGroupExtentRequest) (*ReadConsumerGroupExtentResult_, error)
	ReadConsumerGroupExtents(ctx thrift.Context, request *ReadConsumerGroupExtentsRequest) (*ReadConsumerGroupExtentsResult_, error)
	ReadConsumerGroupExtentsByExtUUID(ctx thrift.Context, request *ReadConsumerGroupExtentsByExtUUIDRequest) (*ReadConsumerGroupExtentsByExtUUIDResult_, error)
	ReadDestination(ctx thrift.Context, getRequest *ReadDestinationRequest) (*shared.DestinationDescription, error)
	ReadExtentStats(ctx thrift.Context, request *ReadExtentStatsRequest) (*ReadExtentStatsResult_, error)
	ReadServiceConfig(ctx thrift.Context, request *ReadServiceConfigRequest) (*ReadServiceConfigResult_, error)
	UUIDToHostAddr(ctx thrift.Context, hostUUID string) (string, error)
	UpdateServiceConfig(ctx thrift.Context, request *UpdateServiceConfigRequest) error
}

// TChanMetadataService is the interface that defines the server handler and client interface.
type TChanMetadataService interface {
	TChanMetadataExposable

	CreateConsumerGroup(ctx thrift.Context, createRequest *shared.CreateConsumerGroupRequest) (*shared.ConsumerGroupDescription, error)
	CreateConsumerGroupExtent(ctx thrift.Context, request *CreateConsumerGroupExtentRequest) error
	CreateDestination(ctx thrift.Context, createRequest *shared.CreateDestinationRequest) (*shared.DestinationDescription, error)
	CreateDestinationUUID(ctx thrift.Context, createRequest *shared.CreateDestinationUUIDRequest) (*shared.DestinationDescription, error)
	CreateExtent(ctx thrift.Context, request *shared.CreateExtentRequest) (*shared.CreateExtentResult_, error)
	CreateHostInfo(ctx thrift.Context, request *CreateHostInfoRequest) error
	DeleteConsumerGroup(ctx thrift.Context, deleteRequest *shared.DeleteConsumerGroupRequest) error
	DeleteDestination(ctx thrift.Context, deleteRequest *shared.DeleteDestinationRequest) error
	DeleteDestinationUUID(ctx thrift.Context, deleteRequest *DeleteDestinationUUIDRequest) error
	DeleteHostInfo(ctx thrift.Context, request *DeleteHostInfoRequest) error
	ListDestinationExtents(ctx thrift.Context, request *ListDestinationExtentsRequest) (*ListDestinationExtentsResult_, error)
	MoveExtent(ctx thrift.Context, request *MoveExtentRequest) error
	ReadConsumerGroupExtentsLite(ctx thrift.Context, request *ReadConsumerGroupExtentsRequest) (*ReadConsumerGroupExtentsLiteResult_, error)
	ReadHostInfo(ctx thrift.Context, request *ReadHostInfoRequest) (*ReadHostInfoResult_, error)
	ReadStoreExtentReplicaStats(ctx thrift.Context, request *ReadStoreExtentReplicaStatsRequest) (*ReadStoreExtentReplicaStatsResult_, error)
	RegisterHostUUID(ctx thrift.Context, request *RegisterHostUUIDRequest) error
	SealExtent(ctx thrift.Context, request *SealExtentRequest) error
	SetAckOffset(ctx thrift.Context, request *SetAckOffsetRequest) error
	SetOutputHost(ctx thrift.Context, request *SetOutputHostRequest) error
	UpdateConsumerGroup(ctx thrift.Context, updateRequest *shared.UpdateConsumerGroupRequest) (*shared.ConsumerGroupDescription, error)
	UpdateConsumerGroupExtentStatus(ctx thrift.Context, request *UpdateConsumerGroupExtentStatusRequest) error
	UpdateDestination(ctx thrift.Context, updateRequest *shared.UpdateDestinationRequest) (*shared.DestinationDescription, error)
	UpdateDestinationDLQCursors(ctx thrift.Context, updateRequest *UpdateDestinationDLQCursorsRequest) (*shared.DestinationDescription, error)
	UpdateExtentReplicaStats(ctx thrift.Context, request *UpdateExtentReplicaStatsRequest) error
	UpdateExtentStats(ctx thrift.Context, request *UpdateExtentStatsRequest) (*UpdateExtentStatsResult_, error)
	UpdateHostInfo(ctx thrift.Context, request *UpdateHostInfoRequest) error
	UpdateStoreExtentReplicaStats(ctx thrift.Context, request *UpdateStoreExtentReplicaStatsRequest) error
}

// Implementation of a client and service handler.

type tchanMetadataExposableClient struct {
	thriftService string
	client        thrift.TChanClient
}

func NewTChanMetadataExposableInheritedClient(thriftService string, client thrift.TChanClient) *tchanMetadataExposableClient {
	return &tchanMetadataExposableClient{
		thriftService,
		client,
	}
}

// NewTChanMetadataExposableClient creates a client that can be used to make remote calls.
func NewTChanMetadataExposableClient(client thrift.TChanClient) TChanMetadataExposable {
	return NewTChanMetadataExposableInheritedClient("MetadataExposable", client)
}

func (c *tchanMetadataExposableClient) ListEntityOps(ctx thrift.Context, listRequest *ListEntityOpsRequest) (*ListEntityOpsResult_, error) {
	var resp MetadataExposableListEntityOpsResult
	args := MetadataExposableListEntityOpsArgs{
		ListRequest: listRequest,
	}
	success, err := c.client.Call(ctx, c.thriftService, "ListEntityOps", &args, &resp)
	if err == nil && !success {
		if e := resp.RequestError; e != nil {
			err = e
		}
		if e := resp.InternalError; e != nil {
			err = e
		}
	}

	return resp.GetSuccess(), err
}

func (c *tchanMetadataExposableClient) CreateServiceConfig(ctx thrift.Context, request *CreateServiceConfigRequest) error {
	var resp MetadataExposableCreateServiceConfigResult
	args := MetadataExposableCreateServiceConfigArgs{
		Request: request,
	}
	success, err := c.client.Call(ctx, c.thriftService, "createServiceConfig", &args, &resp)
	if err == nil && !success {
		if e := resp.Error; e != nil {
			err = e
		}
	}

	return err
}

func (c *tchanMetadataExposableClient) DeleteServiceConfig(ctx thrift.Context, request *DeleteServiceConfigRequest) error {
	var resp MetadataExposableDeleteServiceConfigResult
	args := MetadataExposableDeleteServiceConfigArgs{
		Request: request,
	}
	success, err := c.client.Call(ctx, c.thriftService, "deleteServiceConfig", &args, &resp)
	if err == nil && !success {
		if e := resp.Error; e != nil {
			err = e
		}
	}

	return err
}

func (c *tchanMetadataExposableClient) HostAddrToUUID(ctx thrift.Context, hostAddr string) (string, error) {
	var resp MetadataExposableHostAddrToUUIDResult
	args := MetadataExposableHostAddrToUUIDArgs{
		HostAddr: hostAddr,
	}
	success, err := c.client.Call(ctx, c.thriftService, "hostAddrToUUID", &args, &resp)
	if err == nil && !success {
		if e := resp.NotExistsError; e != nil {
			err = e
		}
		if e := resp.InternalError; e != nil {
			err = e
		}
	}

	return resp.GetSuccess(), err
}

func (c *tchanMetadataExposableClient) ListAllConsumerGroups(ctx thrift.Context, listRequest *ListConsumerGroupRequest) (*ListConsumerGroupResult_, error) {
	var resp MetadataExposableListAllConsumerGroupsResult
	args := MetadataExposableListAllConsumerGroupsArgs{
		ListRequest: listRequest,
	}
	success, err := c.client.Call(ctx, c.thriftService, "listAllConsumerGroups", &args, &resp)
	if err == nil && !success {
		if e := resp.RequestError; e != nil {
			err = e
		}
		if e := resp.InternalError; e != nil {
			err = e
		}
	}

	return resp.GetSuccess(), err
}

func (c *tchanMetadataExposableClient) ListConsumerGroups(ctx thrift.Context, listRequest *ListConsumerGroupRequest) (*ListConsumerGroupResult_, error) {
	var resp MetadataExposableListConsumerGroupsResult
	args := MetadataExposableListConsumerGroupsArgs{
		ListRequest: listRequest,
	}
	success, err := c.client.Call(ctx, c.thriftService, "listConsumerGroups", &args, &resp)
	if err == nil && !success {
		if e := resp.RequestError; e != nil {
			err = e
		}
		if e := resp.InternalError; e != nil {
			err = e
		}
	}

	return resp.GetSuccess(), err
}

func (c *tchanMetadataExposableClient) ListDestinations(ctx thrift.Context, listRequest *shared.ListDestinationsRequest) (*shared.ListDestinationsResult_, error) {
	var resp MetadataExposableListDestinationsResult
	args := MetadataExposableListDestinationsArgs{
		ListRequest: listRequest,
	}
	success, err := c.client.Call(ctx, c.thriftService, "listDestinations", &args, &resp)
	if err == nil && !success {
		if e := resp.RequestError; e != nil {
			err = e
		}
		if e := resp.InternalServiceError; e != nil {
			err = e
		}
	}

	return resp.GetSuccess(), err
}

func (c *tchanMetadataExposableClient) ListDestinationsByUUID(ctx thrift.Context, listRequest *shared.ListDestinationsByUUIDRequest) (*shared.ListDestinationsResult_, error) {
	var resp MetadataExposableListDestinationsByUUIDResult
	args := MetadataExposableListDestinationsByUUIDArgs{
		ListRequest: listRequest,
	}
	success, err := c.client.Call(ctx, c.thriftService, "listDestinationsByUUID", &args, &resp)
	if err == nil && !success {
		if e := resp.RequestError; e != nil {
			err = e
		}
		if e := resp.InternalServiceError; e != nil {
			err = e
		}
	}

	return resp.GetSuccess(), err
}

func (c *tchanMetadataExposableClient) ListExtentsStats(ctx thrift.Context, request *shared.ListExtentsStatsRequest) (*shared.ListExtentsStatsResult_, error) {
	var resp MetadataExposableListExtentsStatsResult
	args := MetadataExposableListExtentsStatsArgs{
		Request: request,
	}
	success, err := c.client.Call(ctx, c.thriftService, "listExtentsStats", &args, &resp)
	if err == nil && !success {
		if e := resp.RequestError; e != nil {
			err = e
		}
		if e := resp.InternalServiceError; e != nil {
			err = e
		}
	}

	return resp.GetSuccess(), err
}

func (c *tchanMetadataExposableClient) ListHosts(ctx thrift.Context, request *ListHostsRequest) (*ListHostsResult_, error) {
	var resp MetadataExposableListHostsResult
	args := MetadataExposableListHostsArgs{
		Request: request,
	}
	success, err := c.client.Call(ctx, c.thriftService, "listHosts", &args, &resp)
	if err == nil && !success {
		if e := resp.RequestError; e != nil {
			err = e
		}
		if e := resp.InternalError; e != nil {
			err = e
		}
	}

	return resp.GetSuccess(), err
}

func (c *tchanMetadataExposableClient) ListInputHostExtentsStats(ctx thrift.Context, request *ListInputHostExtentsStatsRequest) (*ListInputHostExtentsStatsResult_, error) {
	var resp MetadataExposableListInputHostExtentsStatsResult
	args := MetadataExposableListInputHostExtentsStatsArgs{
		Request: request,
	}
	success, err := c.client.Call(ctx, c.thriftService, "listInputHostExtentsStats", &args, &resp)
	if err == nil && !success {
		if e := resp.RequestError; e != nil {
			err = e
		}
		if e := resp.InternalError; e != nil {
			err = e
		}
	}

	return resp.GetSuccess(), err
}

func (c *tchanMetadataExposableClient) ListStoreExtentsStats(ctx thrift.Context, request *ListStoreExtentsStatsRequest) (*ListStoreExtentsStatsResult_, error) {
	var resp MetadataExposableListStoreExtentsStatsResult
	args := MetadataExposableListStoreExtentsStatsArgs{
		Request: request,
	}
	success, err := c.client.Call(ctx, c.thriftService, "listStoreExtentsStats", &args, &resp)
	if err == nil && !success {
		if e := resp.RequestError; e != nil {
			err = e
		}
		if e := resp.InternalError; e != nil {
			err = e
		}
	}

	return resp.GetSuccess(), err
}

func (c *tchanMetadataExposableClient) ReadConsumerGroup(ctx thrift.Context, getRequest *ReadConsumerGroupRequest) (*shared.ConsumerGroupDescription, error) {
	var resp MetadataExposableReadConsumerGroupResult
	args := MetadataExposableReadConsumerGroupArgs{
		GetRequest: getRequest,
	}
	success, err := c.client.Call(ctx, c.thriftService, "readConsumerGroup", &args, &resp)
	if err == nil && !success {
		if e := resp.EntityError; e != nil {
			err = e
		}
		if e := resp.RequestError; e != nil {
			err = e
		}
		if e := resp.InternalServiceError; e != nil {
			err = e
		}
	}

	return resp.GetSuccess(), err
}

func (c *tchanMetadataExposableClient) ReadConsumerGroupByUUID(ctx thrift.Context, request *ReadConsumerGroupRequest) (*shared.ConsumerGroupDescription, error) {
	var resp MetadataExposableReadConsumerGroupByUUIDResult
	args := MetadataExposableReadConsumerGroupByUUIDArgs{
		Request: request,
	}
	success, err := c.client.Call(ctx, c.thriftService, "readConsumerGroupByUUID", &args, &resp)
	if err == nil && !success {
		if e := resp.RequestError; e != nil {
			err = e
		}
		if e := resp.EntityError; e != nil {
			err = e
		}
		if e := resp.InternalServiceError; e != nil {
			err = e
		}
	}

	return resp.GetSuccess(), err
}

func (c *tchanMetadataExposableClient) ReadConsumerGroupExtent(ctx thrift.Context, request *ReadConsumerGroupExtentRequest) (*ReadConsumerGroupExtentResult_, error) {
	var resp MetadataExposableReadConsumerGroupExtentResult
	args := MetadataExposableReadConsumerGroupExtentArgs{
		Request: request,
	}
	success, err := c.client.Call(ctx, c.thriftService, "readConsumerGroupExtent", &args, &resp)
	if err == nil && !success {
		if e := resp.RequestError; e != nil {
			err = e
		}
		if e := resp.InternalError; e != nil {
			err = e
		}
	}

	return resp.GetSuccess(), err
}

func (c *tchanMetadataExposableClient) ReadConsumerGroupExtents(ctx thrift.Context, request *ReadConsumerGroupExtentsRequest) (*ReadConsumerGroupExtentsResult_, error) {
	var resp MetadataExposableReadConsumerGroupExtentsResult
	args := MetadataExposableReadConsumerGroupExtentsArgs{
		Request: request,
	}
	success, err := c.client.Call(ctx, c.thriftService, "readConsumerGroupExtents", &args, &resp)
	if err == nil && !success {
		if e := resp.RequestError; e != nil {
			err = e
		}
		if e := resp.InternalError; e != nil {
			err = e
		}
	}

	return resp.GetSuccess(), err
}

func (c *tchanMetadataExposableClient) ReadConsumerGroupExtentsByExtUUID(ctx thrift.Context, request *ReadConsumerGroupExtentsByExtUUIDRequest) (*ReadConsumerGroupExtentsByExtUUIDResult_, error) {
	var resp MetadataExposableReadConsumerGroupExtentsByExtUUIDResult
	args := MetadataExposableReadConsumerGroupExtentsByExtUUIDArgs{
		Request: request,
	}
	success, err := c.client.Call(ctx, c.thriftService, "readConsumerGroupExtentsByExtUUID", &args, &resp)
	if err == nil && !success {
		if e := resp.RequestError; e != nil {
			err = e
		}
		if e := resp.InternalError; e != nil {
			err = e
		}
	}

	return resp.GetSuccess(), err
}

func (c *tchanMetadataExposableClient) ReadDestination(ctx thrift.Context, getRequest *ReadDestinationRequest) (*shared.DestinationDescription, error) {
	var resp MetadataExposableReadDestinationResult
	args := MetadataExposableReadDestinationArgs{
		GetRequest: getRequest,
	}
	success, err := c.client.Call(ctx, c.thriftService, "readDestination", &args, &resp)
	if err == nil && !success {
		if e := resp.EntityError; e != nil {
			err = e
		}
		if e := resp.RequestError; e != nil {
			err = e
		}
		if e := resp.InternalServiceError; e != nil {
			err = e
		}
	}

	return resp.GetSuccess(), err
}

func (c *tchanMetadataExposableClient) ReadExtentStats(ctx thrift.Context, request *ReadExtentStatsRequest) (*ReadExtentStatsResult_, error) {
	var resp MetadataExposableReadExtentStatsResult
	args := MetadataExposableReadExtentStatsArgs{
		Request: request,
	}
	success, err := c.client.Call(ctx, c.thriftService, "readExtentStats", &args, &resp)
	if err == nil && !success {
		if e := resp.RequestError; e != nil {
			err = e
		}
		if e := resp.InternalError; e != nil {
			err = e
		}
	}

	return resp.GetSuccess(), err
}

func (c *tchanMetadataExposableClient) ReadServiceConfig(ctx thrift.Context, request *ReadServiceConfigRequest) (*ReadServiceConfigResult_, error) {
	var resp MetadataExposableReadServiceConfigResult
	args := MetadataExposableReadServiceConfigArgs{
		Request: request,
	}
	success, err := c.client.Call(ctx, c.thriftService, "readServiceConfig", &args, &resp)
	if err == nil && !success {
		if e := resp.Error; e != nil {
			err = e
		}
	}

	return resp.GetSuccess(), err
}

func (c *tchanMetadataExposableClient) UUIDToHostAddr(ctx thrift.Context, hostUUID string) (string, error) {
	var resp MetadataExposableUUIDToHostAddrResult
	args := MetadataExposableUUIDToHostAddrArgs{
		HostUUID: hostUUID,
	}
	success, err := c.client.Call(ctx, c.thriftService, "uUIDToHostAddr", &args, &resp)
	if err == nil && !success {
		if e := resp.NotExistsError; e != nil {
			err = e
		}
		if e := resp.InternalError; e != nil {
			err = e
		}
	}

	return resp.GetSuccess(), err
}

func (c *tchanMetadataExposableClient) UpdateServiceConfig(ctx thrift.Context, request *UpdateServiceConfigRequest) error {
	var resp MetadataExposableUpdateServiceConfigResult
	args := MetadataExposableUpdateServiceConfigArgs{
		Request: request,
	}
	success, err := c.client.Call(ctx, c.thriftService, "updateServiceConfig", &args, &resp)
	if err == nil && !success {
		if e := resp.Error; e != nil {
			err = e
		}
	}

	return err
}

type tchanMetadataExposableServer struct {
	handler TChanMetadataExposable
}

// NewTChanMetadataExposableServer wraps a handler for TChanMetadataExposable so it can be
// registered with a thrift.Server.
func NewTChanMetadataExposableServer(handler TChanMetadataExposable) thrift.TChanServer {
	return &tchanMetadataExposableServer{
		handler,
	}
}

func (s *tchanMetadataExposableServer) Service() string {
	return "MetadataExposable"
}

func (s *tchanMetadataExposableServer) Methods() []string {
	return []string{
		"ListEntityOps",
		"createServiceConfig",
		"deleteServiceConfig",
		"hostAddrToUUID",
		"listAllConsumerGroups",
		"listConsumerGroups",
		"listDestinations",
		"listDestinationsByUUID",
		"listExtentsStats",
		"listHosts",
		"listInputHostExtentsStats",
		"listStoreExtentsStats",
		"readConsumerGroup",
		"readConsumerGroupByUUID",
		"readConsumerGroupExtent",
		"readConsumerGroupExtents",
		"readConsumerGroupExtentsByExtUUID",
		"readDestination",
		"readExtentStats",
		"readServiceConfig",
		"uUIDToHostAddr",
		"updateServiceConfig",
	}
}

func (s *tchanMetadataExposableServer) Handle(ctx thrift.Context, methodName string, protocol athrift.TProtocol) (bool, athrift.TStruct, error) {
	switch methodName {
	case "ListEntityOps":
		return s.handleListEntityOps(ctx, protocol)
	case "createServiceConfig":
		return s.handleCreateServiceConfig(ctx, protocol)
	case "deleteServiceConfig":
		return s.handleDeleteServiceConfig(ctx, protocol)
	case "hostAddrToUUID":
		return s.handleHostAddrToUUID(ctx, protocol)
	case "listAllConsumerGroups":
		return s.handleListAllConsumerGroups(ctx, protocol)
	case "listConsumerGroups":
		return s.handleListConsumerGroups(ctx, protocol)
	case "listDestinations":
		return s.handleListDestinations(ctx, protocol)
	case "listDestinationsByUUID":
		return s.handleListDestinationsByUUID(ctx, protocol)
	case "listExtentsStats":
		return s.handleListExtentsStats(ctx, protocol)
	case "listHosts":
		return s.handleListHosts(ctx, protocol)
	case "listInputHostExtentsStats":
		return s.handleListInputHostExtentsStats(ctx, protocol)
	case "listStoreExtentsStats":
		return s.handleListStoreExtentsStats(ctx, protocol)
	case "readConsumerGroup":
		return s.handleReadConsumerGroup(ctx, protocol)
	case "readConsumerGroupByUUID":
		return s.handleReadConsumerGroupByUUID(ctx, protocol)
	case "readConsumerGroupExtent":
		return s.handleReadConsumerGroupExtent(ctx, protocol)
	case "readConsumerGroupExtents":
		return s.handleReadConsumerGroupExtents(ctx, protocol)
	case "readConsumerGroupExtentsByExtUUID":
		return s.handleReadConsumerGroupExtentsByExtUUID(ctx, protocol)
	case "readDestination":
		return s.handleReadDestination(ctx, protocol)
	case "readExtentStats":
		return s.handleReadExtentStats(ctx, protocol)
	case "readServiceConfig":
		return s.handleReadServiceConfig(ctx, protocol)
	case "uUIDToHostAddr":
		return s.handleUUIDToHostAddr(ctx, protocol)
	case "updateServiceConfig":
		return s.handleUpdateServiceConfig(ctx, protocol)

	default:
		return false, nil, fmt.Errorf("method %v not found in service %v", methodName, s.Service())
	}
}

func (s *tchanMetadataExposableServer) handleListEntityOps(ctx thrift.Context, protocol athrift.TProtocol) (bool, athrift.TStruct, error) {
	var req MetadataExposableListEntityOpsArgs
	var res MetadataExposableListEntityOpsResult

	if err := req.Read(protocol); err != nil {
		return false, nil, err
	}

	r, err :=
		s.handler.ListEntityOps(ctx, req.ListRequest)

	if err != nil {
		switch v := err.(type) {
		case *shared.BadRequestError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for requestError returned non-nil error type *shared.BadRequestError but nil value")
			}
			res.RequestError = v
		case *shared.InternalServiceError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for internalError returned non-nil error type *shared.InternalServiceError but nil value")
			}
			res.InternalError = v
		default:
			return false, nil, err
		}
	} else {
		res.Success = r
	}

	return err == nil, &res, nil
}

func (s *tchanMetadataExposableServer) handleCreateServiceConfig(ctx thrift.Context, protocol athrift.TProtocol) (bool, athrift.TStruct, error) {
	var req MetadataExposableCreateServiceConfigArgs
	var res MetadataExposableCreateServiceConfigResult

	if err := req.Read(protocol); err != nil {
		return false, nil, err
	}

	err :=
		s.handler.CreateServiceConfig(ctx, req.Request)

	if err != nil {
		switch v := err.(type) {
		case *shared.InternalServiceError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for errorA1 returned non-nil error type *shared.InternalServiceError but nil value")
			}
			res.Error = v
		default:
			return false, nil, err
		}
	} else {
	}

	return err == nil, &res, nil
}

func (s *tchanMetadataExposableServer) handleDeleteServiceConfig(ctx thrift.Context, protocol athrift.TProtocol) (bool, athrift.TStruct, error) {
	var req MetadataExposableDeleteServiceConfigArgs
	var res MetadataExposableDeleteServiceConfigResult

	if err := req.Read(protocol); err != nil {
		return false, nil, err
	}

	err :=
		s.handler.DeleteServiceConfig(ctx, req.Request)

	if err != nil {
		switch v := err.(type) {
		case *shared.InternalServiceError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for errorA1 returned non-nil error type *shared.InternalServiceError but nil value")
			}
			res.Error = v
		default:
			return false, nil, err
		}
	} else {
	}

	return err == nil, &res, nil
}

func (s *tchanMetadataExposableServer) handleHostAddrToUUID(ctx thrift.Context, protocol athrift.TProtocol) (bool, athrift.TStruct, error) {
	var req MetadataExposableHostAddrToUUIDArgs
	var res MetadataExposableHostAddrToUUIDResult

	if err := req.Read(protocol); err != nil {
		return false, nil, err
	}

	r, err :=
		s.handler.HostAddrToUUID(ctx, req.HostAddr)

	if err != nil {
		switch v := err.(type) {
		case *shared.EntityNotExistsError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for notExistsError returned non-nil error type *shared.EntityNotExistsError but nil value")
			}
			res.NotExistsError = v
		case *shared.InternalServiceError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for internalError returned non-nil error type *shared.InternalServiceError but nil value")
			}
			res.InternalError = v
		default:
			return false, nil, err
		}
	} else {
		res.Success = &r
	}

	return err == nil, &res, nil
}

func (s *tchanMetadataExposableServer) handleListAllConsumerGroups(ctx thrift.Context, protocol athrift.TProtocol) (bool, athrift.TStruct, error) {
	var req MetadataExposableListAllConsumerGroupsArgs
	var res MetadataExposableListAllConsumerGroupsResult

	if err := req.Read(protocol); err != nil {
		return false, nil, err
	}

	r, err :=
		s.handler.ListAllConsumerGroups(ctx, req.ListRequest)

	if err != nil {
		switch v := err.(type) {
		case *shared.BadRequestError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for requestError returned non-nil error type *shared.BadRequestError but nil value")
			}
			res.RequestError = v
		case *shared.InternalServiceError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for internalError returned non-nil error type *shared.InternalServiceError but nil value")
			}
			res.InternalError = v
		default:
			return false, nil, err
		}
	} else {
		res.Success = r
	}

	return err == nil, &res, nil
}

func (s *tchanMetadataExposableServer) handleListConsumerGroups(ctx thrift.Context, protocol athrift.TProtocol) (bool, athrift.TStruct, error) {
	var req MetadataExposableListConsumerGroupsArgs
	var res MetadataExposableListConsumerGroupsResult

	if err := req.Read(protocol); err != nil {
		return false, nil, err
	}

	r, err :=
		s.handler.ListConsumerGroups(ctx, req.ListRequest)

	if err != nil {
		switch v := err.(type) {
		case *shared.BadRequestError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for requestError returned non-nil error type *shared.BadRequestError but nil value")
			}
			res.RequestError = v
		case *shared.InternalServiceError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for internalError returned non-nil error type *shared.InternalServiceError but nil value")
			}
			res.InternalError = v
		default:
			return false, nil, err
		}
	} else {
		res.Success = r
	}

	return err == nil, &res, nil
}

func (s *tchanMetadataExposableServer) handleListDestinations(ctx thrift.Context, protocol athrift.TProtocol) (bool, athrift.TStruct, error) {
	var req MetadataExposableListDestinationsArgs
	var res MetadataExposableListDestinationsResult

	if err := req.Read(protocol); err != nil {
		return false, nil, err
	}

	r, err :=
		s.handler.ListDestinations(ctx, req.ListRequest)

	if err != nil {
		switch v := err.(type) {
		case *shared.BadRequestError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for requestError returned non-nil error type *shared.BadRequestError but nil value")
			}
			res.RequestError = v
		case *shared.InternalServiceError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for internalServiceError returned non-nil error type *shared.InternalServiceError but nil value")
			}
			res.InternalServiceError = v
		default:
			return false, nil, err
		}
	} else {
		res.Success = r
	}

	return err == nil, &res, nil
}

func (s *tchanMetadataExposableServer) handleListDestinationsByUUID(ctx thrift.Context, protocol athrift.TProtocol) (bool, athrift.TStruct, error) {
	var req MetadataExposableListDestinationsByUUIDArgs
	var res MetadataExposableListDestinationsByUUIDResult

	if err := req.Read(protocol); err != nil {
		return false, nil, err
	}

	r, err :=
		s.handler.ListDestinationsByUUID(ctx, req.ListRequest)

	if err != nil {
		switch v := err.(type) {
		case *shared.BadRequestError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for requestError returned non-nil error type *shared.BadRequestError but nil value")
			}
			res.RequestError = v
		case *shared.InternalServiceError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for internalServiceError returned non-nil error type *shared.InternalServiceError but nil value")
			}
			res.InternalServiceError = v
		default:
			return false, nil, err
		}
	} else {
		res.Success = r
	}

	return err == nil, &res, nil
}

func (s *tchanMetadataExposableServer) handleListExtentsStats(ctx thrift.Context, protocol athrift.TProtocol) (bool, athrift.TStruct, error) {
	var req MetadataExposableListExtentsStatsArgs
	var res MetadataExposableListExtentsStatsResult

	if err := req.Read(protocol); err != nil {
		return false, nil, err
	}

	r, err :=
		s.handler.ListExtentsStats(ctx, req.Request)

	if err != nil {
		switch v := err.(type) {
		case *shared.BadRequestError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for requestError returned non-nil error type *shared.BadRequestError but nil value")
			}
			res.RequestError = v
		case *shared.InternalServiceError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for internalServiceError returned non-nil error type *shared.InternalServiceError but nil value")
			}
			res.InternalServiceError = v
		default:
			return false, nil, err
		}
	} else {
		res.Success = r
	}

	return err == nil, &res, nil
}

func (s *tchanMetadataExposableServer) handleListHosts(ctx thrift.Context, protocol athrift.TProtocol) (bool, athrift.TStruct, error) {
	var req MetadataExposableListHostsArgs
	var res MetadataExposableListHostsResult

	if err := req.Read(protocol); err != nil {
		return false, nil, err
	}

	r, err :=
		s.handler.ListHosts(ctx, req.Request)

	if err != nil {
		switch v := err.(type) {
		case *shared.BadRequestError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for requestError returned non-nil error type *shared.BadRequestError but nil value")
			}
			res.RequestError = v
		case *shared.InternalServiceError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for internalError returned non-nil error type *shared.InternalServiceError but nil value")
			}
			res.InternalError = v
		default:
			return false, nil, err
		}
	} else {
		res.Success = r
	}

	return err == nil, &res, nil
}

func (s *tchanMetadataExposableServer) handleListInputHostExtentsStats(ctx thrift.Context, protocol athrift.TProtocol) (bool, athrift.TStruct, error) {
	var req MetadataExposableListInputHostExtentsStatsArgs
	var res MetadataExposableListInputHostExtentsStatsResult

	if err := req.Read(protocol); err != nil {
		return false, nil, err
	}

	r, err :=
		s.handler.ListInputHostExtentsStats(ctx, req.Request)

	if err != nil {
		switch v := err.(type) {
		case *shared.BadRequestError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for requestError returned non-nil error type *shared.BadRequestError but nil value")
			}
			res.RequestError = v
		case *shared.InternalServiceError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for internalError returned non-nil error type *shared.InternalServiceError but nil value")
			}
			res.InternalError = v
		default:
			return false, nil, err
		}
	} else {
		res.Success = r
	}

	return err == nil, &res, nil
}

func (s *tchanMetadataExposableServer) handleListStoreExtentsStats(ctx thrift.Context, protocol athrift.TProtocol) (bool, athrift.TStruct, error) {
	var req MetadataExposableListStoreExtentsStatsArgs
	var res MetadataExposableListStoreExtentsStatsResult

	if err := req.Read(protocol); err != nil {
		return false, nil, err
	}

	r, err :=
		s.handler.ListStoreExtentsStats(ctx, req.Request)

	if err != nil {
		switch v := err.(type) {
		case *shared.BadRequestError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for requestError returned non-nil error type *shared.BadRequestError but nil value")
			}
			res.RequestError = v
		case *shared.InternalServiceError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for internalError returned non-nil error type *shared.InternalServiceError but nil value")
			}
			res.InternalError = v
		default:
			return false, nil, err
		}
	} else {
		res.Success = r
	}

	return err == nil, &res, nil
}

func (s *tchanMetadataExposableServer) handleReadConsumerGroup(ctx thrift.Context, protocol athrift.TProtocol) (bool, athrift.TStruct, error) {
	var req MetadataExposableReadConsumerGroupArgs
	var res MetadataExposableReadConsumerGroupResult

	if err := req.Read(protocol); err != nil {
		return false, nil, err
	}

	r, err :=
		s.handler.ReadConsumerGroup(ctx, req.GetRequest)

	if err != nil {
		switch v := err.(type) {
		case *shared.EntityNotExistsError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for entityError returned non-nil error type *shared.EntityNotExistsError but nil value")
			}
			res.EntityError = v
		case *shared.BadRequestError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for requestError returned non-nil error type *shared.BadRequestError but nil value")
			}
			res.RequestError = v
		case *shared.InternalServiceError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for internalServiceError returned non-nil error type *shared.InternalServiceError but nil value")
			}
			res.InternalServiceError = v
		default:
			return false, nil, err
		}
	} else {
		res.Success = r
	}

	return err == nil, &res, nil
}

func (s *tchanMetadataExposableServer) handleReadConsumerGroupByUUID(ctx thrift.Context, protocol athrift.TProtocol) (bool, athrift.TStruct, error) {
	var req MetadataExposableReadConsumerGroupByUUIDArgs
	var res MetadataExposableReadConsumerGroupByUUIDResult

	if err := req.Read(protocol); err != nil {
		return false, nil, err
	}

	r, err :=
		s.handler.ReadConsumerGroupByUUID(ctx, req.Request)

	if err != nil {
		switch v := err.(type) {
		case *shared.BadRequestError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for requestError returned non-nil error type *shared.BadRequestError but nil value")
			}
			res.RequestError = v
		case *shared.EntityNotExistsError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for entityError returned non-nil error type *shared.EntityNotExistsError but nil value")
			}
			res.EntityError = v
		case *shared.InternalServiceError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for internalServiceError returned non-nil error type *shared.InternalServiceError but nil value")
			}
			res.InternalServiceError = v
		default:
			return false, nil, err
		}
	} else {
		res.Success = r
	}

	return err == nil, &res, nil
}

func (s *tchanMetadataExposableServer) handleReadConsumerGroupExtent(ctx thrift.Context, protocol athrift.TProtocol) (bool, athrift.TStruct, error) {
	var req MetadataExposableReadConsumerGroupExtentArgs
	var res MetadataExposableReadConsumerGroupExtentResult

	if err := req.Read(protocol); err != nil {
		return false, nil, err
	}

	r, err :=
		s.handler.ReadConsumerGroupExtent(ctx, req.Request)

	if err != nil {
		switch v := err.(type) {
		case *shared.BadRequestError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for requestError returned non-nil error type *shared.BadRequestError but nil value")
			}
			res.RequestError = v
		case *shared.InternalServiceError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for internalError returned non-nil error type *shared.InternalServiceError but nil value")
			}
			res.InternalError = v
		default:
			return false, nil, err
		}
	} else {
		res.Success = r
	}

	return err == nil, &res, nil
}

func (s *tchanMetadataExposableServer) handleReadConsumerGroupExtents(ctx thrift.Context, protocol athrift.TProtocol) (bool, athrift.TStruct, error) {
	var req MetadataExposableReadConsumerGroupExtentsArgs
	var res MetadataExposableReadConsumerGroupExtentsResult

	if err := req.Read(protocol); err != nil {
		return false, nil, err
	}

	r, err :=
		s.handler.ReadConsumerGroupExtents(ctx, req.Request)

	if err != nil {
		switch v := err.(type) {
		case *shared.BadRequestError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for requestError returned non-nil error type *shared.BadRequestError but nil value")
			}
			res.RequestError = v
		case *shared.InternalServiceError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for internalError returned non-nil error type *shared.InternalServiceError but nil value")
			}
			res.InternalError = v
		default:
			return false, nil, err
		}
	} else {
		res.Success = r
	}

	return err == nil, &res, nil
}

func (s *tchanMetadataExposableServer) handleReadConsumerGroupExtentsByExtUUID(ctx thrift.Context, protocol athrift.TProtocol) (bool, athrift.TStruct, error) {
	var req MetadataExposableReadConsumerGroupExtentsByExtUUIDArgs
	var res MetadataExposableReadConsumerGroupExtentsByExtUUIDResult

	if err := req.Read(protocol); err != nil {
		return false, nil, err
	}

	r, err :=
		s.handler.ReadConsumerGroupExtentsByExtUUID(ctx, req.Request)

	if err != nil {
		switch v := err.(type) {
		case *shared.BadRequestError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for requestError returned non-nil error type *shared.BadRequestError but nil value")
			}
			res.RequestError = v
		case *shared.InternalServiceError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for internalError returned non-nil error type *shared.InternalServiceError but nil value")
			}
			res.InternalError = v
		default:
			return false, nil, err
		}
	} else {
		res.Success = r
	}

	return err == nil, &res, nil
}

func (s *tchanMetadataExposableServer) handleReadDestination(ctx thrift.Context, protocol athrift.TProtocol) (bool, athrift.TStruct, error) {
	var req MetadataExposableReadDestinationArgs
	var res MetadataExposableReadDestinationResult

	if err := req.Read(protocol); err != nil {
		return false, nil, err
	}

	r, err :=
		s.handler.ReadDestination(ctx, req.GetRequest)

	if err != nil {
		switch v := err.(type) {
		case *shared.EntityNotExistsError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for entityError returned non-nil error type *shared.EntityNotExistsError but nil value")
			}
			res.EntityError = v
		case *shared.BadRequestError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for requestError returned non-nil error type *shared.BadRequestError but nil value")
			}
			res.RequestError = v
		case *shared.InternalServiceError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for internalServiceError returned non-nil error type *shared.InternalServiceError but nil value")
			}
			res.InternalServiceError = v
		default:
			return false, nil, err
		}
	} else {
		res.Success = r
	}

	return err == nil, &res, nil
}

func (s *tchanMetadataExposableServer) handleReadExtentStats(ctx thrift.Context, protocol athrift.TProtocol) (bool, athrift.TStruct, error) {
	var req MetadataExposableReadExtentStatsArgs
	var res MetadataExposableReadExtentStatsResult

	if err := req.Read(protocol); err != nil {
		return false, nil, err
	}

	r, err :=
		s.handler.ReadExtentStats(ctx, req.Request)

	if err != nil {
		switch v := err.(type) {
		case *shared.BadRequestError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for requestError returned non-nil error type *shared.BadRequestError but nil value")
			}
			res.RequestError = v
		case *shared.InternalServiceError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for internalError returned non-nil error type *shared.InternalServiceError but nil value")
			}
			res.InternalError = v
		default:
			return false, nil, err
		}
	} else {
		res.Success = r
	}

	return err == nil, &res, nil
}

func (s *tchanMetadataExposableServer) handleReadServiceConfig(ctx thrift.Context, protocol athrift.TProtocol) (bool, athrift.TStruct, error) {
	var req MetadataExposableReadServiceConfigArgs
	var res MetadataExposableReadServiceConfigResult

	if err := req.Read(protocol); err != nil {
		return false, nil, err
	}

	r, err :=
		s.handler.ReadServiceConfig(ctx, req.Request)

	if err != nil {
		switch v := err.(type) {
		case *shared.InternalServiceError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for errorA1 returned non-nil error type *shared.InternalServiceError but nil value")
			}
			res.Error = v
		default:
			return false, nil, err
		}
	} else {
		res.Success = r
	}

	return err == nil, &res, nil
}

func (s *tchanMetadataExposableServer) handleUUIDToHostAddr(ctx thrift.Context, protocol athrift.TProtocol) (bool, athrift.TStruct, error) {
	var req MetadataExposableUUIDToHostAddrArgs
	var res MetadataExposableUUIDToHostAddrResult

	if err := req.Read(protocol); err != nil {
		return false, nil, err
	}

	r, err :=
		s.handler.UUIDToHostAddr(ctx, req.HostUUID)

	if err != nil {
		switch v := err.(type) {
		case *shared.EntityNotExistsError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for notExistsError returned non-nil error type *shared.EntityNotExistsError but nil value")
			}
			res.NotExistsError = v
		case *shared.InternalServiceError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for internalError returned non-nil error type *shared.InternalServiceError but nil value")
			}
			res.InternalError = v
		default:
			return false, nil, err
		}
	} else {
		res.Success = &r
	}

	return err == nil, &res, nil
}

func (s *tchanMetadataExposableServer) handleUpdateServiceConfig(ctx thrift.Context, protocol athrift.TProtocol) (bool, athrift.TStruct, error) {
	var req MetadataExposableUpdateServiceConfigArgs
	var res MetadataExposableUpdateServiceConfigResult

	if err := req.Read(protocol); err != nil {
		return false, nil, err
	}

	err :=
		s.handler.UpdateServiceConfig(ctx, req.Request)

	if err != nil {
		switch v := err.(type) {
		case *shared.InternalServiceError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for errorA1 returned non-nil error type *shared.InternalServiceError but nil value")
			}
			res.Error = v
		default:
			return false, nil, err
		}
	} else {
	}

	return err == nil, &res, nil
}

type tchanMetadataServiceClient struct {
	TChanMetadataExposable

	thriftService string
	client        thrift.TChanClient
}

func NewTChanMetadataServiceInheritedClient(thriftService string, client thrift.TChanClient) *tchanMetadataServiceClient {
	return &tchanMetadataServiceClient{
		NewTChanMetadataExposableInheritedClient(thriftService, client),
		thriftService,
		client,
	}
}

// NewTChanMetadataServiceClient creates a client that can be used to make remote calls.
func NewTChanMetadataServiceClient(client thrift.TChanClient) TChanMetadataService {
	return NewTChanMetadataServiceInheritedClient("MetadataService", client)
}

func (c *tchanMetadataServiceClient) CreateConsumerGroup(ctx thrift.Context, createRequest *shared.CreateConsumerGroupRequest) (*shared.ConsumerGroupDescription, error) {
	var resp MetadataServiceCreateConsumerGroupResult
	args := MetadataServiceCreateConsumerGroupArgs{
		CreateRequest: createRequest,
	}
	success, err := c.client.Call(ctx, c.thriftService, "createConsumerGroup", &args, &resp)
	if err == nil && !success {
		if e := resp.EntityExistsError; e != nil {
			err = e
		}
		if e := resp.RequestError; e != nil {
			err = e
		}
		if e := resp.EntityNotExistsError; e != nil {
			err = e
		}
		if e := resp.InternalServiceError; e != nil {
			err = e
		}
	}

	return resp.GetSuccess(), err
}

func (c *tchanMetadataServiceClient) CreateConsumerGroupExtent(ctx thrift.Context, request *CreateConsumerGroupExtentRequest) error {
	var resp MetadataServiceCreateConsumerGroupExtentResult
	args := MetadataServiceCreateConsumerGroupExtentArgs{
		Request: request,
	}
	success, err := c.client.Call(ctx, c.thriftService, "createConsumerGroupExtent", &args, &resp)
	if err == nil && !success {
		if e := resp.InternalServiceError; e != nil {
			err = e
		}
	}

	return err
}

func (c *tchanMetadataServiceClient) CreateDestination(ctx thrift.Context, createRequest *shared.CreateDestinationRequest) (*shared.DestinationDescription, error) {
	var resp MetadataServiceCreateDestinationResult
	args := MetadataServiceCreateDestinationArgs{
		CreateRequest: createRequest,
	}
	success, err := c.client.Call(ctx, c.thriftService, "createDestination", &args, &resp)
	if err == nil && !success {
		if e := resp.EntityExistsError; e != nil {
			err = e
		}
		if e := resp.RequestError; e != nil {
			err = e
		}
		if e := resp.InternalServiceError; e != nil {
			err = e
		}
	}

	return resp.GetSuccess(), err
}

func (c *tchanMetadataServiceClient) CreateDestinationUUID(ctx thrift.Context, createRequest *shared.CreateDestinationUUIDRequest) (*shared.DestinationDescription, error) {
	var resp MetadataServiceCreateDestinationUUIDResult
	args := MetadataServiceCreateDestinationUUIDArgs{
		CreateRequest: createRequest,
	}
	success, err := c.client.Call(ctx, c.thriftService, "createDestinationUUID", &args, &resp)
	if err == nil && !success {
		if e := resp.EntityExistsError; e != nil {
			err = e
		}
		if e := resp.RequestError; e != nil {
			err = e
		}
		if e := resp.InternalServiceError; e != nil {
			err = e
		}
	}

	return resp.GetSuccess(), err
}

func (c *tchanMetadataServiceClient) CreateExtent(ctx thrift.Context, request *shared.CreateExtentRequest) (*shared.CreateExtentResult_, error) {
	var resp MetadataServiceCreateExtentResult
	args := MetadataServiceCreateExtentArgs{
		Request: request,
	}
	success, err := c.client.Call(ctx, c.thriftService, "createExtent", &args, &resp)
	if err == nil && !success {
		if e := resp.RequestError; e != nil {
			err = e
		}
		if e := resp.EntityExistsError; e != nil {
			err = e
		}
		if e := resp.InternalServiceError; e != nil {
			err = e
		}
	}

	return resp.GetSuccess(), err
}

func (c *tchanMetadataServiceClient) CreateHostInfo(ctx thrift.Context, request *CreateHostInfoRequest) error {
	var resp MetadataServiceCreateHostInfoResult
	args := MetadataServiceCreateHostInfoArgs{
		Request: request,
	}
	success, err := c.client.Call(ctx, c.thriftService, "createHostInfo", &args, &resp)
	if err == nil && !success {
		if e := resp.Error; e != nil {
			err = e
		}
	}

	return err
}

func (c *tchanMetadataServiceClient) DeleteConsumerGroup(ctx thrift.Context, deleteRequest *shared.DeleteConsumerGroupRequest) error {
	var resp MetadataServiceDeleteConsumerGroupResult
	args := MetadataServiceDeleteConsumerGroupArgs{
		DeleteRequest: deleteRequest,
	}
	success, err := c.client.Call(ctx, c.thriftService, "deleteConsumerGroup", &args, &resp)
	if err == nil && !success {
		if e := resp.EntityError; e != nil {
			err = e
		}
		if e := resp.RequestError; e != nil {
			err = e
		}
		if e := resp.InternalServiceError; e != nil {
			err = e
		}
	}

	return err
}

func (c *tchanMetadataServiceClient) DeleteDestination(ctx thrift.Context, deleteRequest *shared.DeleteDestinationRequest) error {
	var resp MetadataServiceDeleteDestinationResult
	args := MetadataServiceDeleteDestinationArgs{
		DeleteRequest: deleteRequest,
	}
	success, err := c.client.Call(ctx, c.thriftService, "deleteDestination", &args, &resp)
	if err == nil && !success {
		if e := resp.EntityError; e != nil {
			err = e
		}
		if e := resp.RequestError; e != nil {
			err = e
		}
		if e := resp.InternalServiceError; e != nil {
			err = e
		}
	}

	return err
}

func (c *tchanMetadataServiceClient) DeleteDestinationUUID(ctx thrift.Context, deleteRequest *DeleteDestinationUUIDRequest) error {
	var resp MetadataServiceDeleteDestinationUUIDResult
	args := MetadataServiceDeleteDestinationUUIDArgs{
		DeleteRequest: deleteRequest,
	}
	success, err := c.client.Call(ctx, c.thriftService, "deleteDestinationUUID", &args, &resp)
	if err == nil && !success {
		if e := resp.EntityError; e != nil {
			err = e
		}
		if e := resp.RequestError; e != nil {
			err = e
		}
		if e := resp.InternalServiceError; e != nil {
			err = e
		}
	}

	return err
}

func (c *tchanMetadataServiceClient) DeleteHostInfo(ctx thrift.Context, request *DeleteHostInfoRequest) error {
	var resp MetadataServiceDeleteHostInfoResult
	args := MetadataServiceDeleteHostInfoArgs{
		Request: request,
	}
	success, err := c.client.Call(ctx, c.thriftService, "deleteHostInfo", &args, &resp)
	if err == nil && !success {
		if e := resp.Error; e != nil {
			err = e
		}
	}

	return err
}

func (c *tchanMetadataServiceClient) ListDestinationExtents(ctx thrift.Context, request *ListDestinationExtentsRequest) (*ListDestinationExtentsResult_, error) {
	var resp MetadataServiceListDestinationExtentsResult
	args := MetadataServiceListDestinationExtentsArgs{
		Request: request,
	}
	success, err := c.client.Call(ctx, c.thriftService, "listDestinationExtents", &args, &resp)
	if err == nil && !success {
		if e := resp.RequestError; e != nil {
			err = e
		}
		if e := resp.InternalServiceError; e != nil {
			err = e
		}
	}

	return resp.GetSuccess(), err
}

func (c *tchanMetadataServiceClient) MoveExtent(ctx thrift.Context, request *MoveExtentRequest) error {
	var resp MetadataServiceMoveExtentResult
	args := MetadataServiceMoveExtentArgs{
		Request: request,
	}
	success, err := c.client.Call(ctx, c.thriftService, "moveExtent", &args, &resp)
	if err == nil && !success {
		if e := resp.RequestError; e != nil {
			err = e
		}
		if e := resp.IllegalStateError; e != nil {
			err = e
		}
		if e := resp.InternalServiceError; e != nil {
			err = e
		}
	}

	return err
}

func (c *tchanMetadataServiceClient) ReadConsumerGroupExtentsLite(ctx thrift.Context, request *ReadConsumerGroupExtentsRequest) (*ReadConsumerGroupExtentsLiteResult_, error) {
	var resp MetadataServiceReadConsumerGroupExtentsLiteResult
	args := MetadataServiceReadConsumerGroupExtentsLiteArgs{
		Request: request,
	}
	success, err := c.client.Call(ctx, c.thriftService, "readConsumerGroupExtentsLite", &args, &resp)
	if err == nil && !success {
		if e := resp.RequestError; e != nil {
			err = e
		}
		if e := resp.InternalServiceError; e != nil {
			err = e
		}
	}

	return resp.GetSuccess(), err
}

func (c *tchanMetadataServiceClient) ReadHostInfo(ctx thrift.Context, request *ReadHostInfoRequest) (*ReadHostInfoResult_, error) {
	var resp MetadataServiceReadHostInfoResult
	args := MetadataServiceReadHostInfoArgs{
		Request: request,
	}
	success, err := c.client.Call(ctx, c.thriftService, "readHostInfo", &args, &resp)
	if err == nil && !success {
		if e := resp.Error; e != nil {
			err = e
		}
	}

	return resp.GetSuccess(), err
}

func (c *tchanMetadataServiceClient) ReadStoreExtentReplicaStats(ctx thrift.Context, request *ReadStoreExtentReplicaStatsRequest) (*ReadStoreExtentReplicaStatsResult_, error) {
	var resp MetadataServiceReadStoreExtentReplicaStatsResult
	args := MetadataServiceReadStoreExtentReplicaStatsArgs{
		Request: request,
	}
	success, err := c.client.Call(ctx, c.thriftService, "readStoreExtentReplicaStats", &args, &resp)
	if err == nil && !success {
		if e := resp.RequestError; e != nil {
			err = e
		}
		if e := resp.InternalServiceError; e != nil {
			err = e
		}
	}

	return resp.GetSuccess(), err
}

func (c *tchanMetadataServiceClient) RegisterHostUUID(ctx thrift.Context, request *RegisterHostUUIDRequest) error {
	var resp MetadataServiceRegisterHostUUIDResult
	args := MetadataServiceRegisterHostUUIDArgs{
		Request: request,
	}
	success, err := c.client.Call(ctx, c.thriftService, "registerHostUUID", &args, &resp)
	if err == nil && !success {
		if e := resp.Error; e != nil {
			err = e
		}
	}

	return err
}

func (c *tchanMetadataServiceClient) SealExtent(ctx thrift.Context, request *SealExtentRequest) error {
	var resp MetadataServiceSealExtentResult
	args := MetadataServiceSealExtentArgs{
		Request: request,
	}
	success, err := c.client.Call(ctx, c.thriftService, "sealExtent", &args, &resp)
	if err == nil && !success {
		if e := resp.RequestError; e != nil {
			err = e
		}
		if e := resp.IllegalStateError; e != nil {
			err = e
		}
		if e := resp.InternalServiceError; e != nil {
			err = e
		}
	}

	return err
}

func (c *tchanMetadataServiceClient) SetAckOffset(ctx thrift.Context, request *SetAckOffsetRequest) error {
	var resp MetadataServiceSetAckOffsetResult
	args := MetadataServiceSetAckOffsetArgs{
		Request: request,
	}
	success, err := c.client.Call(ctx, c.thriftService, "setAckOffset", &args, &resp)
	if err == nil && !success {
		if e := resp.InternalServiceError; e != nil {
			err = e
		}
	}

	return err
}

func (c *tchanMetadataServiceClient) SetOutputHost(ctx thrift.Context, request *SetOutputHostRequest) error {
	var resp MetadataServiceSetOutputHostResult
	args := MetadataServiceSetOutputHostArgs{
		Request: request,
	}
	success, err := c.client.Call(ctx, c.thriftService, "setOutputHost", &args, &resp)
	if err == nil && !success {
		if e := resp.InternalServiceError; e != nil {
			err = e
		}
	}

	return err
}

func (c *tchanMetadataServiceClient) UpdateConsumerGroup(ctx thrift.Context, updateRequest *shared.UpdateConsumerGroupRequest) (*shared.ConsumerGroupDescription, error) {
	var resp MetadataServiceUpdateConsumerGroupResult
	args := MetadataServiceUpdateConsumerGroupArgs{
		UpdateRequest: updateRequest,
	}
	success, err := c.client.Call(ctx, c.thriftService, "updateConsumerGroup", &args, &resp)
	if err == nil && !success {
		if e := resp.EntityError; e != nil {
			err = e
		}
		if e := resp.RequestError; e != nil {
			err = e
		}
		if e := resp.InternalServiceError; e != nil {
			err = e
		}
	}

	return resp.GetSuccess(), err
}

func (c *tchanMetadataServiceClient) UpdateConsumerGroupExtentStatus(ctx thrift.Context, request *UpdateConsumerGroupExtentStatusRequest) error {
	var resp MetadataServiceUpdateConsumerGroupExtentStatusResult
	args := MetadataServiceUpdateConsumerGroupExtentStatusArgs{
		Request: request,
	}
	success, err := c.client.Call(ctx, c.thriftService, "updateConsumerGroupExtentStatus", &args, &resp)
	if err == nil && !success {
		if e := resp.RequestError; e != nil {
			err = e
		}
		if e := resp.InternalServiceError; e != nil {
			err = e
		}
		if e := resp.NotExistsError; e != nil {
			err = e
		}
	}

	return err
}

func (c *tchanMetadataServiceClient) UpdateDestination(ctx thrift.Context, updateRequest *shared.UpdateDestinationRequest) (*shared.DestinationDescription, error) {
	var resp MetadataServiceUpdateDestinationResult
	args := MetadataServiceUpdateDestinationArgs{
		UpdateRequest: updateRequest,
	}
	success, err := c.client.Call(ctx, c.thriftService, "updateDestination", &args, &resp)
	if err == nil && !success {
		if e := resp.EntityError; e != nil {
			err = e
		}
		if e := resp.RequestError; e != nil {
			err = e
		}
		if e := resp.InternalServiceError; e != nil {
			err = e
		}
	}

	return resp.GetSuccess(), err
}

func (c *tchanMetadataServiceClient) UpdateDestinationDLQCursors(ctx thrift.Context, updateRequest *UpdateDestinationDLQCursorsRequest) (*shared.DestinationDescription, error) {
	var resp MetadataServiceUpdateDestinationDLQCursorsResult
	args := MetadataServiceUpdateDestinationDLQCursorsArgs{
		UpdateRequest: updateRequest,
	}
	success, err := c.client.Call(ctx, c.thriftService, "updateDestinationDLQCursors", &args, &resp)
	if err == nil && !success {
		if e := resp.EntityError; e != nil {
			err = e
		}
		if e := resp.RequestError; e != nil {
			err = e
		}
		if e := resp.InternalServiceError; e != nil {
			err = e
		}
	}

	return resp.GetSuccess(), err
}

func (c *tchanMetadataServiceClient) UpdateExtentReplicaStats(ctx thrift.Context, request *UpdateExtentReplicaStatsRequest) error {
	var resp MetadataServiceUpdateExtentReplicaStatsResult
	args := MetadataServiceUpdateExtentReplicaStatsArgs{
		Request: request,
	}
	success, err := c.client.Call(ctx, c.thriftService, "updateExtentReplicaStats", &args, &resp)
	if err == nil && !success {
		if e := resp.RequestError; e != nil {
			err = e
		}
		if e := resp.InternalServiceError; e != nil {
			err = e
		}
	}

	return err
}

func (c *tchanMetadataServiceClient) UpdateExtentStats(ctx thrift.Context, request *UpdateExtentStatsRequest) (*UpdateExtentStatsResult_, error) {
	var resp MetadataServiceUpdateExtentStatsResult
	args := MetadataServiceUpdateExtentStatsArgs{
		Request: request,
	}
	success, err := c.client.Call(ctx, c.thriftService, "updateExtentStats", &args, &resp)
	if err == nil && !success {
		if e := resp.RequestError; e != nil {
			err = e
		}
		if e := resp.EntityNotExistsError; e != nil {
			err = e
		}
		if e := resp.InternalServiceError; e != nil {
			err = e
		}
	}

	return resp.GetSuccess(), err
}

func (c *tchanMetadataServiceClient) UpdateHostInfo(ctx thrift.Context, request *UpdateHostInfoRequest) error {
	var resp MetadataServiceUpdateHostInfoResult
	args := MetadataServiceUpdateHostInfoArgs{
		Request: request,
	}
	success, err := c.client.Call(ctx, c.thriftService, "updateHostInfo", &args, &resp)
	if err == nil && !success {
		if e := resp.Error; e != nil {
			err = e
		}
	}

	return err
}

func (c *tchanMetadataServiceClient) UpdateStoreExtentReplicaStats(ctx thrift.Context, request *UpdateStoreExtentReplicaStatsRequest) error {
	var resp MetadataServiceUpdateStoreExtentReplicaStatsResult
	args := MetadataServiceUpdateStoreExtentReplicaStatsArgs{
		Request: request,
	}
	success, err := c.client.Call(ctx, c.thriftService, "updateStoreExtentReplicaStats", &args, &resp)
	if err == nil && !success {
		if e := resp.RequestError; e != nil {
			err = e
		}
		if e := resp.InternalServiceError; e != nil {
			err = e
		}
	}

	return err
}

type tchanMetadataServiceServer struct {
	thrift.TChanServer

	handler TChanMetadataService
}

// NewTChanMetadataServiceServer wraps a handler for TChanMetadataService so it can be
// registered with a thrift.Server.
func NewTChanMetadataServiceServer(handler TChanMetadataService) thrift.TChanServer {
	return &tchanMetadataServiceServer{
		NewTChanMetadataExposableServer(handler),
		handler,
	}
}

func (s *tchanMetadataServiceServer) Service() string {
	return "MetadataService"
}

func (s *tchanMetadataServiceServer) Methods() []string {
	return []string{
		"createConsumerGroup",
		"createConsumerGroupExtent",
		"createDestination",
		"createDestinationUUID",
		"createExtent",
		"createHostInfo",
		"deleteConsumerGroup",
		"deleteDestination",
		"deleteDestinationUUID",
		"deleteHostInfo",
		"listDestinationExtents",
		"moveExtent",
		"readConsumerGroupExtentsLite",
		"readHostInfo",
		"readStoreExtentReplicaStats",
		"registerHostUUID",
		"sealExtent",
		"setAckOffset",
		"setOutputHost",
		"updateConsumerGroup",
		"updateConsumerGroupExtentStatus",
		"updateDestination",
		"updateDestinationDLQCursors",
		"updateExtentReplicaStats",
		"updateExtentStats",
		"updateHostInfo",
		"updateStoreExtentReplicaStats",

		"ListEntityOps",
		"createServiceConfig",
		"deleteServiceConfig",
		"hostAddrToUUID",
		"listAllConsumerGroups",
		"listConsumerGroups",
		"listDestinations",
		"listDestinationsByUUID",
		"listExtentsStats",
		"listHosts",
		"listInputHostExtentsStats",
		"listStoreExtentsStats",
		"readConsumerGroup",
		"readConsumerGroupByUUID",
		"readConsumerGroupExtent",
		"readConsumerGroupExtents",
		"readConsumerGroupExtentsByExtUUID",
		"readDestination",
		"readExtentStats",
		"readServiceConfig",
		"uUIDToHostAddr",
		"updateServiceConfig",
	}
}

func (s *tchanMetadataServiceServer) Handle(ctx thrift.Context, methodName string, protocol athrift.TProtocol) (bool, athrift.TStruct, error) {
	switch methodName {
	case "createConsumerGroup":
		return s.handleCreateConsumerGroup(ctx, protocol)
	case "createConsumerGroupExtent":
		return s.handleCreateConsumerGroupExtent(ctx, protocol)
	case "createDestination":
		return s.handleCreateDestination(ctx, protocol)
	case "createDestinationUUID":
		return s.handleCreateDestinationUUID(ctx, protocol)
	case "createExtent":
		return s.handleCreateExtent(ctx, protocol)
	case "createHostInfo":
		return s.handleCreateHostInfo(ctx, protocol)
	case "deleteConsumerGroup":
		return s.handleDeleteConsumerGroup(ctx, protocol)
	case "deleteDestination":
		return s.handleDeleteDestination(ctx, protocol)
	case "deleteDestinationUUID":
		return s.handleDeleteDestinationUUID(ctx, protocol)
	case "deleteHostInfo":
		return s.handleDeleteHostInfo(ctx, protocol)
	case "listDestinationExtents":
		return s.handleListDestinationExtents(ctx, protocol)
	case "moveExtent":
		return s.handleMoveExtent(ctx, protocol)
	case "readConsumerGroupExtentsLite":
		return s.handleReadConsumerGroupExtentsLite(ctx, protocol)
	case "readHostInfo":
		return s.handleReadHostInfo(ctx, protocol)
	case "readStoreExtentReplicaStats":
		return s.handleReadStoreExtentReplicaStats(ctx, protocol)
	case "registerHostUUID":
		return s.handleRegisterHostUUID(ctx, protocol)
	case "sealExtent":
		return s.handleSealExtent(ctx, protocol)
	case "setAckOffset":
		return s.handleSetAckOffset(ctx, protocol)
	case "setOutputHost":
		return s.handleSetOutputHost(ctx, protocol)
	case "updateConsumerGroup":
		return s.handleUpdateConsumerGroup(ctx, protocol)
	case "updateConsumerGroupExtentStatus":
		return s.handleUpdateConsumerGroupExtentStatus(ctx, protocol)
	case "updateDestination":
		return s.handleUpdateDestination(ctx, protocol)
	case "updateDestinationDLQCursors":
		return s.handleUpdateDestinationDLQCursors(ctx, protocol)
	case "updateExtentReplicaStats":
		return s.handleUpdateExtentReplicaStats(ctx, protocol)
	case "updateExtentStats":
		return s.handleUpdateExtentStats(ctx, protocol)
	case "updateHostInfo":
		return s.handleUpdateHostInfo(ctx, protocol)
	case "updateStoreExtentReplicaStats":
		return s.handleUpdateStoreExtentReplicaStats(ctx, protocol)

	case "ListEntityOps":
		return s.TChanServer.Handle(ctx, methodName, protocol)
	case "createServiceConfig":
		return s.TChanServer.Handle(ctx, methodName, protocol)
	case "deleteServiceConfig":
		return s.TChanServer.Handle(ctx, methodName, protocol)
	case "hostAddrToUUID":
		return s.TChanServer.Handle(ctx, methodName, protocol)
	case "listAllConsumerGroups":
		return s.TChanServer.Handle(ctx, methodName, protocol)
	case "listConsumerGroups":
		return s.TChanServer.Handle(ctx, methodName, protocol)
	case "listDestinations":
		return s.TChanServer.Handle(ctx, methodName, protocol)
	case "listDestinationsByUUID":
		return s.TChanServer.Handle(ctx, methodName, protocol)
	case "listExtentsStats":
		return s.TChanServer.Handle(ctx, methodName, protocol)
	case "listHosts":
		return s.TChanServer.Handle(ctx, methodName, protocol)
	case "listInputHostExtentsStats":
		return s.TChanServer.Handle(ctx, methodName, protocol)
	case "listStoreExtentsStats":
		return s.TChanServer.Handle(ctx, methodName, protocol)
	case "readConsumerGroup":
		return s.TChanServer.Handle(ctx, methodName, protocol)
	case "readConsumerGroupByUUID":
		return s.TChanServer.Handle(ctx, methodName, protocol)
	case "readConsumerGroupExtent":
		return s.TChanServer.Handle(ctx, methodName, protocol)
	case "readConsumerGroupExtents":
		return s.TChanServer.Handle(ctx, methodName, protocol)
	case "readConsumerGroupExtentsByExtUUID":
		return s.TChanServer.Handle(ctx, methodName, protocol)
	case "readDestination":
		return s.TChanServer.Handle(ctx, methodName, protocol)
	case "readExtentStats":
		return s.TChanServer.Handle(ctx, methodName, protocol)
	case "readServiceConfig":
		return s.TChanServer.Handle(ctx, methodName, protocol)
	case "uUIDToHostAddr":
		return s.TChanServer.Handle(ctx, methodName, protocol)
	case "updateServiceConfig":
		return s.TChanServer.Handle(ctx, methodName, protocol)
	default:
		return false, nil, fmt.Errorf("method %v not found in service %v", methodName, s.Service())
	}
}

func (s *tchanMetadataServiceServer) handleCreateConsumerGroup(ctx thrift.Context, protocol athrift.TProtocol) (bool, athrift.TStruct, error) {
	var req MetadataServiceCreateConsumerGroupArgs
	var res MetadataServiceCreateConsumerGroupResult

	if err := req.Read(protocol); err != nil {
		return false, nil, err
	}

	r, err :=
		s.handler.CreateConsumerGroup(ctx, req.CreateRequest)

	if err != nil {
		switch v := err.(type) {
		case *shared.EntityAlreadyExistsError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for entityExistsError returned non-nil error type *shared.EntityAlreadyExistsError but nil value")
			}
			res.EntityExistsError = v
		case *shared.BadRequestError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for requestError returned non-nil error type *shared.BadRequestError but nil value")
			}
			res.RequestError = v
		case *shared.EntityNotExistsError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for entityNotExistsError returned non-nil error type *shared.EntityNotExistsError but nil value")
			}
			res.EntityNotExistsError = v
		case *shared.InternalServiceError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for internalServiceError returned non-nil error type *shared.InternalServiceError but nil value")
			}
			res.InternalServiceError = v
		default:
			return false, nil, err
		}
	} else {
		res.Success = r
	}

	return err == nil, &res, nil
}

func (s *tchanMetadataServiceServer) handleCreateConsumerGroupExtent(ctx thrift.Context, protocol athrift.TProtocol) (bool, athrift.TStruct, error) {
	var req MetadataServiceCreateConsumerGroupExtentArgs
	var res MetadataServiceCreateConsumerGroupExtentResult

	if err := req.Read(protocol); err != nil {
		return false, nil, err
	}

	err :=
		s.handler.CreateConsumerGroupExtent(ctx, req.Request)

	if err != nil {
		switch v := err.(type) {
		case *shared.InternalServiceError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for internalServiceError returned non-nil error type *shared.InternalServiceError but nil value")
			}
			res.InternalServiceError = v
		default:
			return false, nil, err
		}
	} else {
	}

	return err == nil, &res, nil
}

func (s *tchanMetadataServiceServer) handleCreateDestination(ctx thrift.Context, protocol athrift.TProtocol) (bool, athrift.TStruct, error) {
	var req MetadataServiceCreateDestinationArgs
	var res MetadataServiceCreateDestinationResult

	if err := req.Read(protocol); err != nil {
		return false, nil, err
	}

	r, err :=
		s.handler.CreateDestination(ctx, req.CreateRequest)

	if err != nil {
		switch v := err.(type) {
		case *shared.EntityAlreadyExistsError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for entityExistsError returned non-nil error type *shared.EntityAlreadyExistsError but nil value")
			}
			res.EntityExistsError = v
		case *shared.BadRequestError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for requestError returned non-nil error type *shared.BadRequestError but nil value")
			}
			res.RequestError = v
		case *shared.InternalServiceError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for internalServiceError returned non-nil error type *shared.InternalServiceError but nil value")
			}
			res.InternalServiceError = v
		default:
			return false, nil, err
		}
	} else {
		res.Success = r
	}

	return err == nil, &res, nil
}

func (s *tchanMetadataServiceServer) handleCreateDestinationUUID(ctx thrift.Context, protocol athrift.TProtocol) (bool, athrift.TStruct, error) {
	var req MetadataServiceCreateDestinationUUIDArgs
	var res MetadataServiceCreateDestinationUUIDResult

	if err := req.Read(protocol); err != nil {
		return false, nil, err
	}

	r, err :=
		s.handler.CreateDestinationUUID(ctx, req.CreateRequest)

	if err != nil {
		switch v := err.(type) {
		case *shared.EntityAlreadyExistsError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for entityExistsError returned non-nil error type *shared.EntityAlreadyExistsError but nil value")
			}
			res.EntityExistsError = v
		case *shared.BadRequestError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for requestError returned non-nil error type *shared.BadRequestError but nil value")
			}
			res.RequestError = v
		case *shared.InternalServiceError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for internalServiceError returned non-nil error type *shared.InternalServiceError but nil value")
			}
			res.InternalServiceError = v
		default:
			return false, nil, err
		}
	} else {
		res.Success = r
	}

	return err == nil, &res, nil
}

func (s *tchanMetadataServiceServer) handleCreateExtent(ctx thrift.Context, protocol athrift.TProtocol) (bool, athrift.TStruct, error) {
	var req MetadataServiceCreateExtentArgs
	var res MetadataServiceCreateExtentResult

	if err := req.Read(protocol); err != nil {
		return false, nil, err
	}

	r, err :=
		s.handler.CreateExtent(ctx, req.Request)

	if err != nil {
		switch v := err.(type) {
		case *shared.BadRequestError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for requestError returned non-nil error type *shared.BadRequestError but nil value")
			}
			res.RequestError = v
		case *shared.EntityAlreadyExistsError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for entityExistsError returned non-nil error type *shared.EntityAlreadyExistsError but nil value")
			}
			res.EntityExistsError = v
		case *shared.InternalServiceError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for internalServiceError returned non-nil error type *shared.InternalServiceError but nil value")
			}
			res.InternalServiceError = v
		default:
			return false, nil, err
		}
	} else {
		res.Success = r
	}

	return err == nil, &res, nil
}

func (s *tchanMetadataServiceServer) handleCreateHostInfo(ctx thrift.Context, protocol athrift.TProtocol) (bool, athrift.TStruct, error) {
	var req MetadataServiceCreateHostInfoArgs
	var res MetadataServiceCreateHostInfoResult

	if err := req.Read(protocol); err != nil {
		return false, nil, err
	}

	err :=
		s.handler.CreateHostInfo(ctx, req.Request)

	if err != nil {
		switch v := err.(type) {
		case *shared.InternalServiceError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for errorA1 returned non-nil error type *shared.InternalServiceError but nil value")
			}
			res.Error = v
		default:
			return false, nil, err
		}
	} else {
	}

	return err == nil, &res, nil
}

func (s *tchanMetadataServiceServer) handleDeleteConsumerGroup(ctx thrift.Context, protocol athrift.TProtocol) (bool, athrift.TStruct, error) {
	var req MetadataServiceDeleteConsumerGroupArgs
	var res MetadataServiceDeleteConsumerGroupResult

	if err := req.Read(protocol); err != nil {
		return false, nil, err
	}

	err :=
		s.handler.DeleteConsumerGroup(ctx, req.DeleteRequest)

	if err != nil {
		switch v := err.(type) {
		case *shared.EntityNotExistsError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for entityError returned non-nil error type *shared.EntityNotExistsError but nil value")
			}
			res.EntityError = v
		case *shared.BadRequestError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for requestError returned non-nil error type *shared.BadRequestError but nil value")
			}
			res.RequestError = v
		case *shared.InternalServiceError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for internalServiceError returned non-nil error type *shared.InternalServiceError but nil value")
			}
			res.InternalServiceError = v
		default:
			return false, nil, err
		}
	} else {
	}

	return err == nil, &res, nil
}

func (s *tchanMetadataServiceServer) handleDeleteDestination(ctx thrift.Context, protocol athrift.TProtocol) (bool, athrift.TStruct, error) {
	var req MetadataServiceDeleteDestinationArgs
	var res MetadataServiceDeleteDestinationResult

	if err := req.Read(protocol); err != nil {
		return false, nil, err
	}

	err :=
		s.handler.DeleteDestination(ctx, req.DeleteRequest)

	if err != nil {
		switch v := err.(type) {
		case *shared.EntityNotExistsError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for entityError returned non-nil error type *shared.EntityNotExistsError but nil value")
			}
			res.EntityError = v
		case *shared.BadRequestError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for requestError returned non-nil error type *shared.BadRequestError but nil value")
			}
			res.RequestError = v
		case *shared.InternalServiceError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for internalServiceError returned non-nil error type *shared.InternalServiceError but nil value")
			}
			res.InternalServiceError = v
		default:
			return false, nil, err
		}
	} else {
	}

	return err == nil, &res, nil
}

func (s *tchanMetadataServiceServer) handleDeleteDestinationUUID(ctx thrift.Context, protocol athrift.TProtocol) (bool, athrift.TStruct, error) {
	var req MetadataServiceDeleteDestinationUUIDArgs
	var res MetadataServiceDeleteDestinationUUIDResult

	if err := req.Read(protocol); err != nil {
		return false, nil, err
	}

	err :=
		s.handler.DeleteDestinationUUID(ctx, req.DeleteRequest)

	if err != nil {
		switch v := err.(type) {
		case *shared.EntityNotExistsError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for entityError returned non-nil error type *shared.EntityNotExistsError but nil value")
			}
			res.EntityError = v
		case *shared.BadRequestError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for requestError returned non-nil error type *shared.BadRequestError but nil value")
			}
			res.RequestError = v
		case *shared.InternalServiceError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for internalServiceError returned non-nil error type *shared.InternalServiceError but nil value")
			}
			res.InternalServiceError = v
		default:
			return false, nil, err
		}
	} else {
	}

	return err == nil, &res, nil
}

func (s *tchanMetadataServiceServer) handleDeleteHostInfo(ctx thrift.Context, protocol athrift.TProtocol) (bool, athrift.TStruct, error) {
	var req MetadataServiceDeleteHostInfoArgs
	var res MetadataServiceDeleteHostInfoResult

	if err := req.Read(protocol); err != nil {
		return false, nil, err
	}

	err :=
		s.handler.DeleteHostInfo(ctx, req.Request)

	if err != nil {
		switch v := err.(type) {
		case *shared.InternalServiceError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for errorA1 returned non-nil error type *shared.InternalServiceError but nil value")
			}
			res.Error = v
		default:
			return false, nil, err
		}
	} else {
	}

	return err == nil, &res, nil
}

func (s *tchanMetadataServiceServer) handleListDestinationExtents(ctx thrift.Context, protocol athrift.TProtocol) (bool, athrift.TStruct, error) {
	var req MetadataServiceListDestinationExtentsArgs
	var res MetadataServiceListDestinationExtentsResult

	if err := req.Read(protocol); err != nil {
		return false, nil, err
	}

	r, err :=
		s.handler.ListDestinationExtents(ctx, req.Request)

	if err != nil {
		switch v := err.(type) {
		case *shared.BadRequestError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for requestError returned non-nil error type *shared.BadRequestError but nil value")
			}
			res.RequestError = v
		case *shared.InternalServiceError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for internalServiceError returned non-nil error type *shared.InternalServiceError but nil value")
			}
			res.InternalServiceError = v
		default:
			return false, nil, err
		}
	} else {
		res.Success = r
	}

	return err == nil, &res, nil
}

func (s *tchanMetadataServiceServer) handleMoveExtent(ctx thrift.Context, protocol athrift.TProtocol) (bool, athrift.TStruct, error) {
	var req MetadataServiceMoveExtentArgs
	var res MetadataServiceMoveExtentResult

	if err := req.Read(protocol); err != nil {
		return false, nil, err
	}

	err :=
		s.handler.MoveExtent(ctx, req.Request)

	if err != nil {
		switch v := err.(type) {
		case *shared.BadRequestError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for requestError returned non-nil error type *shared.BadRequestError but nil value")
			}
			res.RequestError = v
		case *IllegalStateError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for illegalStateError returned non-nil error type *IllegalStateError but nil value")
			}
			res.IllegalStateError = v
		case *shared.InternalServiceError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for internalServiceError returned non-nil error type *shared.InternalServiceError but nil value")
			}
			res.InternalServiceError = v
		default:
			return false, nil, err
		}
	} else {
	}

	return err == nil, &res, nil
}

func (s *tchanMetadataServiceServer) handleReadConsumerGroupExtentsLite(ctx thrift.Context, protocol athrift.TProtocol) (bool, athrift.TStruct, error) {
	var req MetadataServiceReadConsumerGroupExtentsLiteArgs
	var res MetadataServiceReadConsumerGroupExtentsLiteResult

	if err := req.Read(protocol); err != nil {
		return false, nil, err
	}

	r, err :=
		s.handler.ReadConsumerGroupExtentsLite(ctx, req.Request)

	if err != nil {
		switch v := err.(type) {
		case *shared.BadRequestError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for requestError returned non-nil error type *shared.BadRequestError but nil value")
			}
			res.RequestError = v
		case *shared.InternalServiceError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for internalServiceError returned non-nil error type *shared.InternalServiceError but nil value")
			}
			res.InternalServiceError = v
		default:
			return false, nil, err
		}
	} else {
		res.Success = r
	}

	return err == nil, &res, nil
}

func (s *tchanMetadataServiceServer) handleReadHostInfo(ctx thrift.Context, protocol athrift.TProtocol) (bool, athrift.TStruct, error) {
	var req MetadataServiceReadHostInfoArgs
	var res MetadataServiceReadHostInfoResult

	if err := req.Read(protocol); err != nil {
		return false, nil, err
	}

	r, err :=
		s.handler.ReadHostInfo(ctx, req.Request)

	if err != nil {
		switch v := err.(type) {
		case *shared.InternalServiceError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for errorA1 returned non-nil error type *shared.InternalServiceError but nil value")
			}
			res.Error = v
		default:
			return false, nil, err
		}
	} else {
		res.Success = r
	}

	return err == nil, &res, nil
}

func (s *tchanMetadataServiceServer) handleReadStoreExtentReplicaStats(ctx thrift.Context, protocol athrift.TProtocol) (bool, athrift.TStruct, error) {
	var req MetadataServiceReadStoreExtentReplicaStatsArgs
	var res MetadataServiceReadStoreExtentReplicaStatsResult

	if err := req.Read(protocol); err != nil {
		return false, nil, err
	}

	r, err :=
		s.handler.ReadStoreExtentReplicaStats(ctx, req.Request)

	if err != nil {
		switch v := err.(type) {
		case *shared.BadRequestError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for requestError returned non-nil error type *shared.BadRequestError but nil value")
			}
			res.RequestError = v
		case *shared.InternalServiceError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for internalServiceError returned non-nil error type *shared.InternalServiceError but nil value")
			}
			res.InternalServiceError = v
		default:
			return false, nil, err
		}
	} else {
		res.Success = r
	}

	return err == nil, &res, nil
}

func (s *tchanMetadataServiceServer) handleRegisterHostUUID(ctx thrift.Context, protocol athrift.TProtocol) (bool, athrift.TStruct, error) {
	var req MetadataServiceRegisterHostUUIDArgs
	var res MetadataServiceRegisterHostUUIDResult

	if err := req.Read(protocol); err != nil {
		return false, nil, err
	}

	err :=
		s.handler.RegisterHostUUID(ctx, req.Request)

	if err != nil {
		switch v := err.(type) {
		case *shared.InternalServiceError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for errorA1 returned non-nil error type *shared.InternalServiceError but nil value")
			}
			res.Error = v
		default:
			return false, nil, err
		}
	} else {
	}

	return err == nil, &res, nil
}

func (s *tchanMetadataServiceServer) handleSealExtent(ctx thrift.Context, protocol athrift.TProtocol) (bool, athrift.TStruct, error) {
	var req MetadataServiceSealExtentArgs
	var res MetadataServiceSealExtentResult

	if err := req.Read(protocol); err != nil {
		return false, nil, err
	}

	err :=
		s.handler.SealExtent(ctx, req.Request)

	if err != nil {
		switch v := err.(type) {
		case *shared.BadRequestError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for requestError returned non-nil error type *shared.BadRequestError but nil value")
			}
			res.RequestError = v
		case *IllegalStateError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for illegalStateError returned non-nil error type *IllegalStateError but nil value")
			}
			res.IllegalStateError = v
		case *shared.InternalServiceError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for internalServiceError returned non-nil error type *shared.InternalServiceError but nil value")
			}
			res.InternalServiceError = v
		default:
			return false, nil, err
		}
	} else {
	}

	return err == nil, &res, nil
}

func (s *tchanMetadataServiceServer) handleSetAckOffset(ctx thrift.Context, protocol athrift.TProtocol) (bool, athrift.TStruct, error) {
	var req MetadataServiceSetAckOffsetArgs
	var res MetadataServiceSetAckOffsetResult

	if err := req.Read(protocol); err != nil {
		return false, nil, err
	}

	err :=
		s.handler.SetAckOffset(ctx, req.Request)

	if err != nil {
		switch v := err.(type) {
		case *shared.InternalServiceError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for internalServiceError returned non-nil error type *shared.InternalServiceError but nil value")
			}
			res.InternalServiceError = v
		default:
			return false, nil, err
		}
	} else {
	}

	return err == nil, &res, nil
}

func (s *tchanMetadataServiceServer) handleSetOutputHost(ctx thrift.Context, protocol athrift.TProtocol) (bool, athrift.TStruct, error) {
	var req MetadataServiceSetOutputHostArgs
	var res MetadataServiceSetOutputHostResult

	if err := req.Read(protocol); err != nil {
		return false, nil, err
	}

	err :=
		s.handler.SetOutputHost(ctx, req.Request)

	if err != nil {
		switch v := err.(type) {
		case *shared.InternalServiceError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for internalServiceError returned non-nil error type *shared.InternalServiceError but nil value")
			}
			res.InternalServiceError = v
		default:
			return false, nil, err
		}
	} else {
	}

	return err == nil, &res, nil
}

func (s *tchanMetadataServiceServer) handleUpdateConsumerGroup(ctx thrift.Context, protocol athrift.TProtocol) (bool, athrift.TStruct, error) {
	var req MetadataServiceUpdateConsumerGroupArgs
	var res MetadataServiceUpdateConsumerGroupResult

	if err := req.Read(protocol); err != nil {
		return false, nil, err
	}

	r, err :=
		s.handler.UpdateConsumerGroup(ctx, req.UpdateRequest)

	if err != nil {
		switch v := err.(type) {
		case *shared.EntityNotExistsError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for entityError returned non-nil error type *shared.EntityNotExistsError but nil value")
			}
			res.EntityError = v
		case *shared.BadRequestError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for requestError returned non-nil error type *shared.BadRequestError but nil value")
			}
			res.RequestError = v
		case *shared.InternalServiceError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for internalServiceError returned non-nil error type *shared.InternalServiceError but nil value")
			}
			res.InternalServiceError = v
		default:
			return false, nil, err
		}
	} else {
		res.Success = r
	}

	return err == nil, &res, nil
}

func (s *tchanMetadataServiceServer) handleUpdateConsumerGroupExtentStatus(ctx thrift.Context, protocol athrift.TProtocol) (bool, athrift.TStruct, error) {
	var req MetadataServiceUpdateConsumerGroupExtentStatusArgs
	var res MetadataServiceUpdateConsumerGroupExtentStatusResult

	if err := req.Read(protocol); err != nil {
		return false, nil, err
	}

	err :=
		s.handler.UpdateConsumerGroupExtentStatus(ctx, req.Request)

	if err != nil {
		switch v := err.(type) {
		case *shared.BadRequestError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for requestError returned non-nil error type *shared.BadRequestError but nil value")
			}
			res.RequestError = v
		case *shared.InternalServiceError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for internalServiceError returned non-nil error type *shared.InternalServiceError but nil value")
			}
			res.InternalServiceError = v
		case *shared.EntityNotExistsError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for notExistsError returned non-nil error type *shared.EntityNotExistsError but nil value")
			}
			res.NotExistsError = v
		default:
			return false, nil, err
		}
	} else {
	}

	return err == nil, &res, nil
}

func (s *tchanMetadataServiceServer) handleUpdateDestination(ctx thrift.Context, protocol athrift.TProtocol) (bool, athrift.TStruct, error) {
	var req MetadataServiceUpdateDestinationArgs
	var res MetadataServiceUpdateDestinationResult

	if err := req.Read(protocol); err != nil {
		return false, nil, err
	}

	r, err :=
		s.handler.UpdateDestination(ctx, req.UpdateRequest)

	if err != nil {
		switch v := err.(type) {
		case *shared.EntityNotExistsError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for entityError returned non-nil error type *shared.EntityNotExistsError but nil value")
			}
			res.EntityError = v
		case *shared.BadRequestError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for requestError returned non-nil error type *shared.BadRequestError but nil value")
			}
			res.RequestError = v
		case *shared.InternalServiceError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for internalServiceError returned non-nil error type *shared.InternalServiceError but nil value")
			}
			res.InternalServiceError = v
		default:
			return false, nil, err
		}
	} else {
		res.Success = r
	}

	return err == nil, &res, nil
}

func (s *tchanMetadataServiceServer) handleUpdateDestinationDLQCursors(ctx thrift.Context, protocol athrift.TProtocol) (bool, athrift.TStruct, error) {
	var req MetadataServiceUpdateDestinationDLQCursorsArgs
	var res MetadataServiceUpdateDestinationDLQCursorsResult

	if err := req.Read(protocol); err != nil {
		return false, nil, err
	}

	r, err :=
		s.handler.UpdateDestinationDLQCursors(ctx, req.UpdateRequest)

	if err != nil {
		switch v := err.(type) {
		case *shared.EntityNotExistsError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for entityError returned non-nil error type *shared.EntityNotExistsError but nil value")
			}
			res.EntityError = v
		case *shared.BadRequestError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for requestError returned non-nil error type *shared.BadRequestError but nil value")
			}
			res.RequestError = v
		case *shared.InternalServiceError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for internalServiceError returned non-nil error type *shared.InternalServiceError but nil value")
			}
			res.InternalServiceError = v
		default:
			return false, nil, err
		}
	} else {
		res.Success = r
	}

	return err == nil, &res, nil
}

func (s *tchanMetadataServiceServer) handleUpdateExtentReplicaStats(ctx thrift.Context, protocol athrift.TProtocol) (bool, athrift.TStruct, error) {
	var req MetadataServiceUpdateExtentReplicaStatsArgs
	var res MetadataServiceUpdateExtentReplicaStatsResult

	if err := req.Read(protocol); err != nil {
		return false, nil, err
	}

	err :=
		s.handler.UpdateExtentReplicaStats(ctx, req.Request)

	if err != nil {
		switch v := err.(type) {
		case *shared.BadRequestError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for requestError returned non-nil error type *shared.BadRequestError but nil value")
			}
			res.RequestError = v
		case *shared.InternalServiceError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for internalServiceError returned non-nil error type *shared.InternalServiceError but nil value")
			}
			res.InternalServiceError = v
		default:
			return false, nil, err
		}
	} else {
	}

	return err == nil, &res, nil
}

func (s *tchanMetadataServiceServer) handleUpdateExtentStats(ctx thrift.Context, protocol athrift.TProtocol) (bool, athrift.TStruct, error) {
	var req MetadataServiceUpdateExtentStatsArgs
	var res MetadataServiceUpdateExtentStatsResult

	if err := req.Read(protocol); err != nil {
		return false, nil, err
	}

	r, err :=
		s.handler.UpdateExtentStats(ctx, req.Request)

	if err != nil {
		switch v := err.(type) {
		case *shared.BadRequestError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for requestError returned non-nil error type *shared.BadRequestError but nil value")
			}
			res.RequestError = v
		case *shared.EntityNotExistsError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for entityNotExistsError returned non-nil error type *shared.EntityNotExistsError but nil value")
			}
			res.EntityNotExistsError = v
		case *shared.InternalServiceError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for internalServiceError returned non-nil error type *shared.InternalServiceError but nil value")
			}
			res.InternalServiceError = v
		default:
			return false, nil, err
		}
	} else {
		res.Success = r
	}

	return err == nil, &res, nil
}

func (s *tchanMetadataServiceServer) handleUpdateHostInfo(ctx thrift.Context, protocol athrift.TProtocol) (bool, athrift.TStruct, error) {
	var req MetadataServiceUpdateHostInfoArgs
	var res MetadataServiceUpdateHostInfoResult

	if err := req.Read(protocol); err != nil {
		return false, nil, err
	}

	err :=
		s.handler.UpdateHostInfo(ctx, req.Request)

	if err != nil {
		switch v := err.(type) {
		case *shared.InternalServiceError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for errorA1 returned non-nil error type *shared.InternalServiceError but nil value")
			}
			res.Error = v
		default:
			return false, nil, err
		}
	} else {
	}

	return err == nil, &res, nil
}

func (s *tchanMetadataServiceServer) handleUpdateStoreExtentReplicaStats(ctx thrift.Context, protocol athrift.TProtocol) (bool, athrift.TStruct, error) {
	var req MetadataServiceUpdateStoreExtentReplicaStatsArgs
	var res MetadataServiceUpdateStoreExtentReplicaStatsResult

	if err := req.Read(protocol); err != nil {
		return false, nil, err
	}

	err :=
		s.handler.UpdateStoreExtentReplicaStats(ctx, req.Request)

	if err != nil {
		switch v := err.(type) {
		case *shared.BadRequestError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for requestError returned non-nil error type *shared.BadRequestError but nil value")
			}
			res.RequestError = v
		case *shared.InternalServiceError:
			if v == nil {
				return false, nil, fmt.Errorf("Handler for internalServiceError returned non-nil error type *shared.InternalServiceError but nil value")
			}
			res.InternalServiceError = v
		default:
			return false, nil, err
		}
	} else {
	}

	return err == nil, &res, nil
}
